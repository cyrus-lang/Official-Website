[
  {
    "id": "en-tutorial-project_configuration",
    "title": "Project Configuration",
    "path": "/en/docs/tutorial/project_configuration",
    "content": "Coming soon......",
    "searchable": "project configuration coming soon...... coming soon...",
    "language": "en",
    "category": "tutorial",
    "weight": 19
  },
  {
    "id": "en-tutorial-inline_assembly",
    "title": "Inline Assembly",
    "path": "/en/docs/tutorial/inline_assembly",
    "content": "Coming soon......",
    "searchable": "inline assembly coming soon...... coming soon...",
    "language": "en",
    "category": "tutorial",
    "weight": 18
  },
  {
    "id": "en-tutorial-FFI",
    "title": "FFI",
    "path": "/en/docs/tutorial/FFI",
    "content": "Coming soon......",
    "searchable": "ffi coming soon...... coming soon...",
    "language": "en",
    "category": "tutorial",
    "weight": 17
  },
  {
    "id": "en-tutorial-macros",
    "title": "Macros",
    "path": "/en/docs/tutorial/macros",
    "content": "Coming soon......",
    "searchable": "macros coming soon...... coming soon...",
    "language": "en",
    "category": "tutorial",
    "weight": 16
  },
  {
    "id": "en-tutorial-reflection",
    "title": "Reflection",
    "path": "/en/docs/tutorial/reflection",
    "content": "Coming soon......",
    "searchable": "reflection coming soon...... coming soon...",
    "language": "en",
    "category": "tutorial",
    "weight": 15
  },
  {
    "id": "en-tutorial-memory_management",
    "title": "Memory Management",
    "path": "/en/docs/tutorial/memory_management",
    "content": "Coming soon......",
    "searchable": "memory management coming soon...... coming soon...",
    "language": "en",
    "category": "tutorial",
    "weight": 14
  },
  {
    "id": "en-tutorial-error_handling",
    "title": "Error Handling",
    "path": "/en/docs/tutorial/error_handling",
    "content": "Coming soon......",
    "searchable": "error handling coming soon...... coming soon...",
    "language": "en",
    "category": "tutorial",
    "weight": 13
  },
  {
    "id": "en-tutorial-modules",
    "title": "Modules",
    "path": "/en/docs/tutorial/modules",
    "content": "Cyrus features a powerful module system with incremental compilation and a strong module cache. Modules allow code organization, reusability, and proper scoping.",
    "searchable": "modules cyrus features a powerful module system with incremental compilation and a strong module cache. modules allow code organization, reusability, and proper scoping. # modules cyrus features a **powerful module system** with **incremental compilation** and a **strong module cache**. modules allow code organization, reusability, and proper scoping. <br /> ## module files in cyrus, **files are considered modules**. module files must: - use **snake_case** names\n- have the .cyrus extension example: user_utils.cyrus defines a module named user_utils. inside user_utils.cyrus: <br /> ## importing modules to use a module in another file, you import it. notes: - the entry file (the one you compile as main) cannot import other modules; it is considered the root.\n- only publicly exported symbols (declared with pub) are visible outside their module. <br /> ## importing single symbols you can import only a single symbol instead of the whole module: <br /> ## importing multiple modules for convenience, cyrus supports grouped imports: <br /> ## renaming imported symbols renaming avoids conflicts or makes names clearer.    - renaming a symbol - renaming a module",
    "language": "en",
    "category": "tutorial",
    "weight": 12
  },
  {
    "id": "en-tutorial-generic_types",
    "title": "Generic Types",
    "path": "/en/docs/tutorial/generic_types",
    "content": "Cyrus supports generic types to create reusable and flexible type constructs. Generics are compile-time constructs, enabling static dispatch. They can be applied to enums, structs, unions, and type aliases.",
    "searchable": "generic types cyrus supports generic types to create reusable and flexible type constructs. generics are compile-time constructs, enabling static dispatch. they can be applied to enums, structs, unions, and type aliases. # generic types cyrus supports **generic types** to create reusable and flexible type constructs. generics are **compile-time constructs**, enabling **static dispatch**. they can be applied to **enums, structs, unions, and type aliases**. <br /> ## 1. generic type constructs <br /> ### 1.1 generic enums * v and e are **generic type parameters**.\n* e has a **default type**, allowing omission during instantiation: <br /> ### 1.2 generic structs * type arguments can be **explicit or inferred** from context: <br /> ### 1.3 generic unions * works like enums but allows **single-value variants**. <br /> ### 1.4 type aliases with generics * reorders generic parameters from the original type.\n* example usage: * defaults can be used: <br /> ## 2. positional and named type arguments <br /> ### 2.1 positional <br /> ### 2.2 named * named arguments **override defaults** regardless of order.\n* mix positional and named arguments as needed. <br /> ## 3. generic type inference compiler resolution order: - explicit type arguments\n- defaults\n- expected type context if inference fails, the compiler reports an error and requires explicit type arguments. <br /> ## 4. combined example * swap<int, string> = pair<string, int>\n* result<float> uses default e=string <br /> ## 5. compile-time vs runtime **generic types in cyrus are compile-time constructs**, also known as **static dispatch**. * code for each concrete instantiation is generated at compile time.\n* no runtime type checks for generics.\n* high performance, as calls are **monomorphized**. <br /> ## 6. runtime polymorphism (uncompleted) * cyrus also supports **runtime polymorphism** via other mechanisms (interfaces or trait-like structures, in progress).\n* generic types are **not runtime-polymorphic**; they remain static. <br /> ## 7. generic functions (uncompleted) * cyrus supports **generic functions**, similar to generic types.\n* placeholders:",
    "language": "en",
    "category": "tutorial",
    "weight": 11
  },
  {
    "id": "en-tutorial-tuples",
    "title": "Tuples",
    "path": "/en/docs/tutorial/tuples",
    "content": "A tuple is an ordered, fixed-size collection of values of possibly different types.",
    "searchable": "tuples a tuple is an ordered, fixed-size collection of values of possibly different types. # tuples a **tuple** is an ordered, fixed-size collection of values of possibly different types.  \nthey are lightweight and useful for grouping, returning, or destructuring multiple values without defining a struct. <br /> ## tuple literals tuples are written using parentheses, with elements separated by commas: you can access tuple elements using numeric indices starting from 0: <br /> ## returning tuples from functions functions can return multiple values by specifying a tuple type as the return type: <br /> ## tuple destructuring tuples can be **destructured** into individual variables in a single declaration.\neach element in the tuple pattern receives the corresponding element from the right-hand side. <br /> ## nested tuples tuples can contain other tuples.\ndestructuring works recursively and matches the shape of the right-hand side: this form can be arbitrarily nested and follows the same destructuring logic for all levels. <br /> ## explicit tuple types you can explicitly annotate tuple types to make destructuring clearer or enforce type constraints: type annotations ensure the tuple on the right-hand side matches the declared structure. <br /> ## mutability the var keyword makes all destructured elements mutable,\nwhile const makes all of them immutable: <br /> ## restrictions - tuple destructuring is only allowed inside **functions** or **local scopes**.\n- destructuring without a right-hand side (e.g., var (a, b);) is **not allowed**,\n  because tuple exports without initialization are meaningless in cyrus. example of invalid code: tuples in cyrus are designed to be type-safe, efficient, and compiler-optimized.\nespecially when destructuring nested or function-returned tuples.",
    "language": "en",
    "category": "tutorial",
    "weight": 10
  },
  {
    "id": "en-getting-started-hello-world",
    "title": "Hello World!",
    "path": "/en/docs/getting-started/hello-world",
    "content": "Let's start with the first program:",
    "searchable": "hello world! let's start with the first program: # hello cyrus! let's start with the first program: <br /> ## compiling the program let's take the above program and put it in a file called **hello_world.cyrus**. we can then run it with: it should print hello, world! and return back to the command line prompt.",
    "language": "en",
    "category": "getting-started",
    "weight": 9
  },
  {
    "id": "en-tutorial-unions",
    "title": "Unions",
    "path": "/en/docs/tutorial/unions",
    "content": "A Union in Cyrus is a composite data type similar to C-style unions.",
    "searchable": "unions a union in cyrus is a composite data type similar to c-style unions. # unions a union in cyrus is a composite data type similar to c-style unions. \nit allows multiple fields to share the same memory location, so only one of its fields can hold a valid value at any given time. unlike structs, writing to one field will overwrite the memory for all others. <br /> <warningalert title=\"unions are not memory-safe\">\n  unions in cyrus are not memory-safe. reading a field that was not most recently \n  written is undefined behavior, just like in c. use unions only when you explicitly \n  need memory-efficient, low-level data representations.\n</warningalert> <infoalert title=\"safe alternative\">\n  if you want a memory-safe way to store different types of values, use an enum, \n  which enforces at compile time which variant is active.\n</infoalert> <br /> ## defining a union <br /> ## using a union you can create a union instance and assign fields directly: after un.b = 3.14, the value of un.a is no longer valid. <br /> ## union initialization unions can be initialized using a union initializer, specifying which field to set at creation: rules: - only one field should be initialized.\n- the union's memory will be set according to that field. <br /> ## practical use cases unions are low-level tools, mainly used in systems programming: - type punning: reinterpret the same memory as different types.\n- interfacing with c libraries: many c apis expose unions in their structs.\n- memory efficiency: when you know only one of several large fields will be used at once. example: interpreting the same 32-bit data as either an integer or raw bytes. output (on little-endian systems):",
    "language": "en",
    "category": "tutorial",
    "weight": 9
  },
  {
    "id": "en-tutorial-enums",
    "title": "Enums",
    "path": "/en/docs/tutorial/enums",
    "content": "Enums in Cyrus are a way to define a type that can hold one value out of a fixed set of variants. Each variant can be a simple tag, a tagged constant, or carry additional fields (like a struct).",
    "searchable": "enums enums in cyrus are a way to define a type that can hold one value out of a fixed set of variants. each variant can be a simple tag, a tagged constant, or carry additional fields (like a struct). # enums enums in cyrus are a way to define a type that can hold one value out of a fixed set of variants. each variant can be a simple tag, a tagged constant, or carry additional fields (like a struct). <br /> ## declaring an enum you declare an enum with the enum keyword, followed by its name and variant list: <br /> ## using enums you construct enum values by qualifying them with the enum's name: <br /> ## matching enum variants the switch statement lets you match a value against the possible variants of an enum. each case corresponds to one variant. if the variant carries fields, you can bind them to local variables inside the case body: <br /> ## fallthrough into enum variants with fields when a case without fields falls through into a case with fields, the compiler must attempt to bind payload variables for the second case. since the actual variant does not contain those fields, the bindings would be undefined, which could lead to undefined behavior at runtime. the compiler will not allow this. if a programmer attempts to write a switch where a fieldless case falls through into a case with fields, the compiler will produce an error, forcing the developer to either terminate the first case with break; or explicitly handle fallthrough safely.",
    "language": "en",
    "category": "tutorial",
    "weight": 8
  },
  {
    "id": "fa-getting-started-roadmap",
    "title": "نقشه راه",
    "path": "/fa/docs/getting-started/roadmap",
    "content": "- [x] نحو پایه",
    "searchable": "نقشه راه - [x] نحو پایه # نقشه راه ## نسخه 1.0 (q2 2024) - [x] نحو پایه\n- [x] سیستم نوع\n- [x] کامپایلر پایه\n- [ ] کتابخانه استاندارد\n- [ ] مستندات کامل ## نسخه 1.1 (q3 2024) - [ ] ماکروها\n- [ ] مدیریت حافظه پیشرفته\n- [ ] بهینه‌سازی‌های بیشتر ## نسخه 2.0 (q4 2024) - [ ] همزمانی\n- [ ] ffi\n- [ ] پکیج منیجر",
    "language": "fa",
    "category": "getting-started",
    "weight": 8
  },
  {
    "id": "en-tutorial-structs",
    "title": "Structs",
    "path": "/en/docs/tutorial/structs",
    "content": "Structs in Cyrus are user-defined composite types that allow grouping related data together.  They are similar to struct in C/C++ but follow Cyrus' type system rules.",
    "searchable": "structs structs in cyrus are user-defined composite types that allow grouping related data together.  they are similar to struct in c/c++ but follow cyrus' type system rules. # structs  structs in cyrus are **user-defined composite types** that allow grouping related data together.  they are similar to struct in c/c++ but follow cyrus' type system rules. <br /> ## defining a struct use the struct keyword, followed by the name and fields: <br /> ## initializing a struct structs can be initialized using **struct literals**: <br /> ## accessing struct fields you can access struct fields using the **dot (.) operator**: <br /> ## methods  structs can define functions inside their body, called **methods**. <br /> ## static methods static methods do not require a struct instance. called on the struct type itself. it often used as constructor or helper functions. <br /> ## instance methods instance methods operate on a struct instance and can access its fields. <br /> ## reference vs copy cyrus allows controlling how instance methods receive the struct: - &self → passes a **reference** to the instance (does not copy)  \n- self → passes a **copy** of the instance (moves it) note: attempting to get a reference (&self) from a const-lvalue is not allowed. the compiler will issue an error to prevent modifying or referencing immutable data. <br /> ## fat arrows in cyrus, you can have pointers to structs. when accessing fields or calling methods through a pointer, you can use **fat pointers** (fat arrows) which **automatically dereference** the pointer. note: using **ptr->name** or **ptr->age** is equivalent to **{\"(*ptr).name\"}** and **{\"(*ptr).age\"}**. <br /> ## local structs in cyrus, structs can also be declared **locally inside functions**. this is useful when the type is only relevant to that function and should not pollute the global scope. <br /> ## unnamed structs unnamed structs are struct values declared inline without defining a named type. they are useful for quick, one-off configurations or temporary data holders. field types are inferred automatically. <br /> ## typed unnamed struct you can also specify field types explicitly: note: unnamed structs cannot define methods. <br /> ## global unnamed structs unnamed structs are not limited to local scope. they can also be declared globally and accessed across functions (if marked public).",
    "language": "en",
    "category": "tutorial",
    "weight": 7
  },
  {
    "id": "fa-getting-started-build-from-source",
    "title": "ساخت از منبع",
    "path": "/fa/docs/getting-started/build-from-source",
    "content": "اگر می‌خواهید سایروس را از کد منبع بسازید:",
    "searchable": "ساخت از منبع اگر می‌خواهید سایروس را از کد منبع بسازید: # ساخت از منبع اگر می‌خواهید سایروس را از کد منبع بسازید: ## پیش‌نیازها - rust 1.70+\n- cargo\n- git ## مراحل ساخت ## نصب",
    "language": "fa",
    "category": "getting-started",
    "weight": 7
  },
  {
    "id": "en-getting-started-build-from-source",
    "title": "Build from source",
    "path": "/en/docs/getting-started/build-from-source",
    "content": "Sometimes you want the freshest bits—whether to contribute to Cyrus itself, test bleeding-edge features, or just peek under the compiler’s hood. Building from source is straightforward and gives you full control over the toolchain.",
    "searchable": "build from source sometimes you want the freshest bits—whether to contribute to cyrus itself, test bleeding-edge features, or just peek under the compiler’s hood. building from source is straightforward and gives you full control over the toolchain. # build from source sometimes you want the freshest bits—whether to contribute to cyrus itself, test bleeding-edge features, or just peek under the compiler’s hood. building from source is straightforward and gives you full control over the toolchain. ### prerequisites before you begin, make sure you have the following installed: - git - to fetch the source code.\n- rust 1.87-nightly.\n- llvm 18. also these native libraries are required: - glibc\n- clang\n- clang-tools\n- libffi\n- ffi\n- ffi-dev\n- isl\n- libxml2 <br /> ## on linux update your package index first: install the dependencies: install rust using rustup: verify installation: <br /> ## macos (via homebrew): install dependencies via homebrew: ensure homebrew’s llvm is in your path (add to ~/.zshrc or ~/.bashrc): install rust using rustup: verify installation: <br /> ## on windows: coming soon... <br /> # clone the repository from the project root: this will produce the cyrus compiler binary in **target/release/cyrus**.",
    "language": "en",
    "category": "getting-started",
    "weight": 6
  },
  {
    "id": "en-tutorial-functions",
    "title": "Functions",
    "path": "/en/docs/tutorial/functions",
    "content": "Functions in Cyrus are defined using the fn keyword, followed by the function name, parameters, and return type.",
    "searchable": "functions functions in cyrus are defined using the fn keyword, followed by the function name, parameters, and return type. # functions functions in cyrus are defined using the fn keyword, followed by the function name, parameters, and return type. <br /> ## basic function example here's a simple example of a function that adds two integers: <br /> ## recursion <br /> # function access specifiers in cyrus, functions can be declared with **access specifiers** that control their visibility and behavior.  \nthese specifiers are placed **before** the fn keyword. - **extern** - declares that the function is defined outside the current module (e.g., in a c library). useful for interoperability. only valid for declarations. - **pub** makes the function visible outside the current module. without pub, a function is private by default and can only be used within the same module. - **inline** hints to the compiler that the function body should be expanded inline at call sites (for performance). this is most effective with **small utility functions**. - **pub inline** a combination: visible outside the module and a candidate for inlining. - **pub extern** declares an **external function** that is also exported from the current module. this is commonly used when exposing bindings or apis. <br /> ## variadic arguments cyrus supports two kinds of variadic arguments, allowing functions to accept a variable number of parameters. <br /> ### c-style variadic arguments c-style variadic functions use the ... notation, just like in c. these are typically used for **interfacing with c libraries** (e.g., printf) or when type safety is not a concern. - use this style primarily for compatibility with c and low-level apis.  \n- inside the function body, such arguments are accessed with platform-specific varargs handling (similar to c's va_list). <br /> ### typed variadic arguments (not implemented yet.) typed variadic functions allow specifying **one type** that repeats for an arbitrary number of arguments. this gives type safety and better compiler optimizations. <br /> ## function abi name  cyrus allows you to specify a **different abi-level (linker) name** for a function than its cyrus name. this is done using the as keyword after the declaration.   - the function is **declared as printf** at the abi level, so it links against the real printf symbol in the c standard library.\n- inside cyrus, however, the function is referred to as **my_printf**.\n- this allows you to avoid naming conflicts or to wrap existing library functions under more descriptive names. <br /> # lambdas lambdas in cyrus are anonymous functions. they look and behave like normal functions, but they don't need a name. you define them inline, assign them to variables, pass them around, or embed them inside structs. unlike closures in some other languages, cyrus lambdas do not capture the surrounding environment. they are pure function objects defined with a clear, fixed signature. <br /> ### function types every lambda has a function type, which describes its parameters and return type.\nfor example: <br /> ### defining a lambda the syntax is straightforward: <br /> ### assigning to variables you can store lambdas in variables: <br /> ### no environment capture in cyrus, **lambdas are not closures**.\nthat means they cannot capture variables from their surrounding scope. for example:",
    "language": "en",
    "category": "tutorial",
    "weight": 6
  },
  {
    "id": "fa-tutorial-functions",
    "title": "توابع",
    "path": "/fa/docs/tutorial/functions",
    "content": "توابع در سایروس برای گروه‌بندی کد و قابلیت استفاده مجدد استفاده می‌شوند.",
    "searchable": "توابع توابع در سایروس برای گروه‌بندی کد و قابلیت استفاده مجدد استفاده می‌شوند. # توابع توابع در سایروس برای گروه‌بندی کد و قابلیت استفاده مجدد استفاده می‌شوند. ## تعریف تابع ساده ## تابع با پارامتر ## تابع با مقدار بازگشتی ## تابع با مقدار بازگشتی ضمنی ## فراخوانی توابع",
    "language": "fa",
    "category": "tutorial",
    "weight": 6
  },
  {
    "id": "fa-getting-started-hello-world",
    "title": "سلام دنیا",
    "path": "/fa/docs/getting-started/hello-world",
    "content": "اولین برنامه شما در سایروس:",
    "searchable": "سلام دنیا اولین برنامه شما در سایروس: # سلام دنیا اولین برنامه شما در سایروس: این ساده‌ترین برنامه ممکن در سایروس است که عبارت \"سلام دنیا\" را چاپ می‌کند.",
    "language": "fa",
    "category": "getting-started",
    "weight": 6
  },
  {
    "id": "en-tutorial-control-flow",
    "title": "Control Flow",
    "path": "/en/docs/tutorial/control-flow",
    "content": "Conditional statements let you execute different blocks of code depending on whether a condition evaluates to true or false. Conditions must evaluate to a bool value.",
    "searchable": "control flow conditional statements let you execute different blocks of code depending on whether a condition evaluates to true or false. conditions must evaluate to a bool value. ## conditional statements conditional statements let you execute different blocks of code depending on whether a condition evaluates to true or false. conditions must evaluate to a bool value. <br /> ## looping constructs a for loop allows repeating a block of code multiple times. it usually consists of three optional parts inside the loop header: - initializer - runs once before the loop begins (often used to declare and initialize a counter).\n- condition - checked before each iteration; if false, the loop exits.\n- increment/update - executed after each iteration. <br /> ### classic counter loop <br /> ### manual increment loop here, the increment part is omitted. the loop continues until the condition becomes false, but you control when i is updated. <br /> ### conditionless loop with initializer only the initializer is given. since there's no condition, the loop is infinite unless explicitly terminated with break or return. <br /> ### pure infinite loop <br /> ### while statement a while loop repeatedly executes a block of code as long as a condition evaluates to true. the condition is checked before each iteration. if the condition is false at the start, the loop body never runs. <br /> ## switch statement a switch statement allows execution to branch based on the value of an expression. it provides a concise way to compare against multiple possibilities without writing a long chain of if–else if statements. ⚠️ note: this is not pattern matching. cases in cyrus are always compared against raw values, not structural patterns or conditions. <br /> ### basic form <br /> ### fallthrough behavior in cyrus, switch statements automatically fall through to the next case unless you explicitly use break.\nthis is the same behavior as in c and c++, and unlike languages such as go or rust where each case ends automatically. <br /> ### enum variants switch statements can also match enum variants, but that will be explained in detail in the future on the enums page.",
    "language": "en",
    "category": "tutorial",
    "weight": 5
  },
  {
    "id": "en-getting-started-install-compiler-binary",
    "title": "Install compiler binary",
    "path": "/en/docs/getting-started/install-compiler-binary",
    "content": "Head over to the releases page and grab the archive for your platform:",
    "searchable": "install compiler binary head over to the releases page and grab the archive for your platform: # install compiler binary  cyrus provides prebuilt binaries for major platforms, available on our [github releases](https://github.com/cyrus-lang/cyrus/releases/) page. <br /> ## 1. download the latest release head over to the releases page and grab the archive for your platform: - linux (x86_64 / arm64)\n- windows (x86_64)\n- macos (intel / apple silicon) <br /> ## 2. extract the zip file after downloading the release archive from github releases, you need to extract it. so you can run cyrus from anywhere, move the binary to a directory in your path: cyrus requires access to its standard library. copy it to a known location (e.g. ~/.cyrus_stdlib): then export the path in your shell config (~/.bashrc, ~/.zshrc, etc.): apply the changes: <br /> ## 3. verify the installation check the compiler works: expected output:",
    "language": "en",
    "category": "getting-started",
    "weight": 5
  },
  {
    "id": "fa-getting-started-getting-started",
    "title": "شروع کنید",
    "path": "/fa/docs/getting-started/getting-started",
    "content": "به سایروس خوش آمدید! این راهنما به شما کمک می‌کند تا اولین قدم‌های خود را در دنیای برنامه‌نویسی با سایروس بردارید.",
    "searchable": "شروع کنید به سایروس خوش آمدید! این راهنما به شما کمک می‌کند تا اولین قدم‌های خود را در دنیای برنامه‌نویسی با سایروس بردارید. # شروع کنید به سایروس خوش آمدید! این راهنما به شما کمک می‌کند تا اولین قدم‌های خود را در دنیای برنامه‌نویسی با سایروس بردارید.",
    "language": "fa",
    "category": "getting-started",
    "weight": 5
  },
  {
    "id": "fa-tutorial-variables",
    "title": "متغیرها",
    "path": "/fa/docs/tutorial/variables",
    "content": "متغیرها در سایروس برای ذخیره داده‌ها استفاده می‌شوند.",
    "searchable": "متغیرها متغیرها در سایروس برای ذخیره داده‌ها استفاده می‌شوند. # متغیرها متغیرها در سایروس برای ذخیره داده‌ها استفاده می‌شوند. #### تعریف متغیر ####  متغیرهای قابل تغییر ####  انواع صریح ####  ثابت‌ها",
    "language": "fa",
    "category": "tutorial",
    "weight": 5
  },
  {
    "id": "fa-getting-started-install-compiler-binary",
    "title": "نصب کامپایلر",
    "path": "/fa/docs/getting-started/install-compiler-binary",
    "content": "برای شروع کار با سایروس، ابتدا باید کامپایلر را نصب کنید.",
    "searchable": "نصب کامپایلر برای شروع کار با سایروس، ابتدا باید کامپایلر را نصب کنید. # نصب کامپایلر برای شروع کار با سایروس، ابتدا باید کامپایلر را نصب کنید. ## ویندوز ## لینوکس ## مک",
    "language": "fa",
    "category": "getting-started",
    "weight": 5
  },
  {
    "id": "en-tutorial-expressions",
    "title": "Expressions",
    "path": "/en/docs/tutorial/expressions",
    "content": "Operators in Cyrus work similarly to those in C. They are categorized by their functionality and precedence.",
    "searchable": "expressions operators in cyrus work similarly to those in c. they are categorized by their functionality and precedence. # operators operators in cyrus work similarly to those in c. they are categorized by their functionality and precedence.\noperators are evaluated based on their precedence (priority) and associativity (left-to-right or right-to-left). <br /> ## arithmetic operators arithmetic operators perform mathematical calculations between numeric operands. <table>\n  <tableheader>\n    <tablerow>\n      <tablehead classname=\"w-[100px]\">operator</tablehead>\n      <tablehead>meaning</tablehead>\n      <tablehead>example</tablehead>\n      <tablehead classname=\"text-right\">result</tablehead>\n    </tablerow>\n  </tableheader>\n  <tablebody>\n    <tablerow>\n      <tablecell classname=\"font-medium\">+</tablecell>\n      <tablecell>addition</tablecell>\n      <tablecell>5 + 2</tablecell>\n      <tablecell classname=\"text-right\">7</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">-</tablecell>\n      <tablecell>subtraction</tablecell>\n      <tablecell>5 - 2</tablecell>\n      <tablecell classname=\"text-right\">3</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">*</tablecell>\n      <tablecell>multiplication</tablecell>\n      <tablecell>5 * 2</tablecell>\n      <tablecell classname=\"text-right\">10</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">/</tablecell>\n      <tablecell>division</tablecell>\n      <tablecell>5 / 2</tablecell>\n      <tablecell classname=\"text-right\">2</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">%</tablecell>\n      <tablecell>modulo (truncated)</tablecell>\n      <tablecell>5 % 2</tablecell>\n      <tablecell classname=\"text-right\">1</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">|</tablecell>\n      <tablecell>bitwise or (integers)</tablecell>\n      <tablecell>6 | 3</tablecell>\n      <tablecell classname=\"text-right\">7</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">~</tablecell>\n      <tablecell>bitwise xor (integers)</tablecell>\n      <tablecell>6 ~ 3</tablecell>\n      <tablecell classname=\"text-right\">5</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">&</tablecell>\n      <tablecell>bitwise and (integers)</tablecell>\n      <tablecell>6 & 3</tablecell>\n      <tablecell classname=\"text-right\">2</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">\n        <code>&~</code>\n      </tablecell>\n      <tablecell>bitwise and-not (integers)</tablecell>\n      <tablecell>6 &~ 3</tablecell>\n      <tablecell classname=\"text-right\">4</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">&lt;&lt;</tablecell>\n      <tablecell>left shift (integer &lt;&lt; non-negative integer)</tablecell>\n      <tablecell>3 &lt;&lt; 2</tablecell>\n      <tablecell classname=\"text-right\">12</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">&gt;&gt;</tablecell>\n      <tablecell>right shift (integer &gt;&gt; non-negative integer)</tablecell>\n      <tablecell>12 &gt;&gt; 2</tablecell>\n      <tablecell classname=\"text-right\">3</tablecell>\n    </tablerow>\n  </tablebody>\n</table> <br /> ## comparison operators comparison operators evaluate the relationship between two operands and return a **bool** result (true or false). <table>\n  <tableheader>\n    <tablerow>\n      <tablehead classname=\"w-[100px]\">operator</tablehead>\n      <tablehead>meaning</tablehead>\n      <tablehead>example</tablehead>\n      <tablehead classname=\"text-right\">result</tablehead>\n    </tablerow>\n  </tableheader>\n  <tablebody>\n    <tablerow>\n      <tablecell classname=\"font-medium\">==</tablecell>\n      <tablecell>equal to</tablecell>\n      <tablecell>5 == 5</tablecell>\n      <tablecell classname=\"text-right\">true</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">!=</tablecell>\n      <tablecell>not equal to</tablecell>\n      <tablecell>5 != 3</tablecell>\n      <tablecell classname=\"text-right\">true</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">&lt;</tablecell>\n      <tablecell>less than</tablecell>\n      <tablecell>3 &lt; 5</tablecell>\n      <tablecell classname=\"text-right\">true</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">&gt;</tablecell>\n      <tablecell>greater than</tablecell>\n      <tablecell>7 &gt; 2</tablecell>\n      <tablecell classname=\"text-right\">true</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">&lt;=</tablecell>\n      <tablecell>less than or equal to</tablecell>\n      <tablecell>3 &lt;= 3</tablecell>\n      <tablecell classname=\"text-right\">true</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">&gt;=</tablecell>\n      <tablecell>greater than or equal to</tablecell>\n      <tablecell>5 &gt;= 2</tablecell>\n      <tablecell classname=\"text-right\">true</tablecell>\n    </tablerow>\n  </tablebody>\n</table> <br /> ## logical operators logical operators are used to combine or invert boolean values. they always operate on true and false values and return a boolean result. <table>\n  <tableheader>\n    <tablerow>\n      <tablehead classname=\"w-[100px]\">operator</tablehead>\n      <tablehead>meaning</tablehead>\n      <tablehead>example</tablehead>\n      <tablehead classname=\"text-right\">result</tablehead>\n    </tablerow>\n  </tableheader>\n  <tablebody>\n    <tablerow>\n      <tablecell classname=\"font-medium\">&amp;&amp;</tablecell>\n      <tablecell>logical and</tablecell>\n      <tablecell>true &amp;&amp; false</tablecell>\n      <tablecell classname=\"text-right\">false</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">||</tablecell>\n      <tablecell>logical or</tablecell>\n      <tablecell>true || false</tablecell>\n      <tablecell classname=\"text-right\">true</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">!</tablecell>\n      <tablecell>logical not</tablecell>\n      <tablecell>!true</tablecell>\n      <tablecell classname=\"text-right\">false</tablecell>\n    </tablerow>\n  </tablebody>\n</table> <br /> ## assignment operators assignment operators are used to assign values to variables.\nthe simplest form is **=**, but there are also compound assignments that perform an operation and assignment in one step. <table>\n  <tableheader>\n    <tablerow>\n      <tablehead classname=\"w-[100px]\">operator</tablehead>\n      <tablehead>meaning</tablehead>\n      <tablehead>example</tablehead>\n      <tablehead classname=\"text-right\">result</tablehead>\n    </tablerow>\n  </tableheader>\n  <tablebody>\n    <tablerow>\n      <tablecell classname=\"font-medium\">=</tablecell>\n      <tablecell>assignment</tablecell>\n      <tablecell>a = 10</tablecell>\n      <tablecell classname=\"text-right\">a = 10</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">+=</tablecell>\n      <tablecell>add and assign</tablecell>\n      <tablecell>a += 5</tablecell>\n      <tablecell classname=\"text-right\">a = a + 5</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">-=</tablecell>\n      <tablecell>subtract and assign</tablecell>\n      <tablecell>a -= 5</tablecell>\n      <tablecell classname=\"text-right\">a = a - 5</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">*=</tablecell>\n      <tablecell>multiply and assign</tablecell>\n      <tablecell>a *= 5</tablecell>\n      <tablecell classname=\"text-right\">a = a * 5</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">/=</tablecell>\n      <tablecell>divide and assign</tablecell>\n      <tablecell>a /= 5</tablecell>\n      <tablecell classname=\"text-right\">a = a / 5</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">%=</tablecell>\n      <tablecell>modulo and assign</tablecell>\n      <tablecell>a %= 5</tablecell>\n      <tablecell classname=\"text-right\">a = a % 5</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">&=</tablecell>\n      <tablecell>bitwise and and assign</tablecell>\n      <tablecell>a &= 5</tablecell>\n      <tablecell classname=\"text-right\">a = a & 5</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">~=</tablecell>\n      <tablecell>bitwise xor and assign</tablecell>\n      <tablecell>a ~= 5</tablecell>\n      <tablecell classname=\"text-right\">a = a ~ 5</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">{\"&~=\"}</tablecell>\n      <tablecell>bitwise and not and assign</tablecell>\n      <tablecell>{\"a &~= 5\"}</tablecell>\n      <tablecell classname=\"text-right\">a = a &~ 5</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">{\"<<=\"}</tablecell>\n      <tablecell>left shift and assign</tablecell>\n      <tablecell>{\"a <<= 2\"}</tablecell>\n      <tablecell classname=\"text-right\">{\"a = a << 2\"}</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">>>=</tablecell>\n      <tablecell>right shift and assign</tablecell>\n      <tablecell>a >>= 2</tablecell>\n      <tablecell classname=\"text-right\">a = a >> 2</tablecell>\n    </tablerow>\n  </tablebody>\n</table> <br /> ## operator precedence & associativity associativity determines how operators of the same precedence are grouped: left-to-right or right-to-left.\nparentheses () can be used to explicitly control evaluation order. <table>\n  <tableheader>\n    <tablerow>\n      <tablehead>operator / type</tablehead>\n      <tablehead>description</tablehead>\n      <tablehead style={{ textalign: \"right\" }}>\n        precedence / associativity\n      </tablehead>\n    </tablerow>\n  </tableheader>\n  <tablebody>\n    <tablerow>\n      <tablecell>lowest</tablecell>\n      <tablecell>\n        represents the lowest precedence. used internally as a default when no\n        other precedence applies.\n      </tablecell>\n      <tablecell style={{ textalign: \"right\" }}>lowest</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>sizeof</tablecell>\n      <tablecell>returns the size of a type or expression in bytes.</tablecell>\n      <tablecell style={{ textalign: \"right\" }}>high / right-to-left</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>||</tablecell>\n      <tablecell>\n        logical or. returns true if at least one operand is true.\n      </tablecell>\n      <tablecell style={{ textalign: \"right\" }}>low / left-to-right</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>&amp;&amp;</tablecell>\n      <tablecell>\n        logical and. returns true only if both operands are true.\n      </tablecell>\n      <tablecell style={{ textalign: \"right\" }}>low / left-to-right</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>==, !=</tablecell>\n      <tablecell>equality and inequality comparison operators.</tablecell>\n      <tablecell style={{ textalign: \"right\" }}>\n        low-mid / left-to-right\n      </tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>&gt;, &lt;, &gt;=, &lt;=</tablecell>\n      <tablecell>relational operators to compare values.</tablecell>\n      <tablecell style={{ textalign: \"right\" }}>mid / left-to-right</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>+, -</tablecell>\n      <tablecell>addition and subtraction operators.</tablecell>\n      <tablecell style={{ textalign: \"right\" }}>\n        mid-high / left-to-right\n      </tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>*, /, %</tablecell>\n      <tablecell>multiplication, division, and modulo operators.</tablecell>\n      <tablecell style={{ textalign: \"right\" }}>high / left-to-right</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>&amp;, |, ~, &amp;~</tablecell>\n      <tablecell>bitwise and, or, not, and custom combination (~&).</tablecell>\n      <tablecell style={{ textalign: \"right\" }}>high / left-to-right</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>-x, !x</tablecell>\n      <tablecell>unary prefix operators: negation and logical not.</tablecell>\n      <tablecell style={{ textalign: \"right\" }}>high / right-to-left</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>&amp;</tablecell>\n      <tablecell>\n        address-of operator. returns the memory address of its operand.\n      </tablecell>\n      <tablecell style={{ textalign: \"right\" }}>\n        lower than member access / right-to-left\n      </tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>*</tablecell>\n      <tablecell>\n        dereference operator. accesses the value pointed to by a pointer.\n      </tablecell>\n      <tablecell style={{ textalign: \"right\" }}>\n        higher than member access / right-to-left\n      </tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>my_function(x)</tablecell>\n      <tablecell>\n        function call. evaluates arguments and calls the function.\n      </tablecell>\n      <tablecell style={{ textalign: \"right\" }}>\n        very high / left-to-right\n      </tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>array[index]</tablecell>\n      <tablecell>\n        array indexing. access the element at a specific position.\n      </tablecell>\n      <tablecell style={{ textalign: \"right\" }}>\n        very high / left-to-right\n      </tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>type conversion (cast)</tablecell>\n      <tablecell>explicitly converts a value to a different type.</tablecell>\n      <tablecell style={{ textalign: \"right\" }}>high / right-to-left</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>.</tablecell>\n      <tablecell>\n        member access. accesses a field of a struct or object.\n      </tablecell>\n      <tablecell style={{ textalign: \"right\" }}>high / left-to-right</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>-&gt;</tablecell>\n      <tablecell>\n        pointer member access. dereferences a pointer to access a field of a\n        struct or object.\n      </tablecell>\n      <tablecell style={{ textalign: \"right\" }}>high / left-to-right</tablecell>\n    </tablerow>\n  </tablebody>\n</table> <br /> ## unary operators unary operators operate on a single operand and modify its value by **1**.  \n**prefix** (++i, --i) updates the variable **before** it’s used in an expression.  \n**postfix** (i++, i--) updates the variable **after** it’s used in an expression. <table> <tableheader>\n  <tablerow>\n    <tablehead classname=\"w-[140px]\">operator</tablehead>\n    <tablehead>meaning</tablehead>\n    <tablehead>example</tablehead>\n    <tablehead classname=\"text-right\">result</tablehead>\n  </tablerow>\n</tableheader> <br /> <tablebody>\n  <tablerow>\n    <tablecell classname=\"font-medium\">i++</tablecell>\n    <tablecell>\n      post-increment: returns current value, then increases by 1\n    </tablecell>\n    <tablecell>i = 5; j = i++</tablecell>\n    <tablecell classname=\"text-right\">i = 6, j = 5</tablecell>\n  </tablerow>\n  <tablerow>\n    <tablecell classname=\"font-medium\">++i</tablecell>\n    <tablecell>\n      pre-increment: increases by 1, then returns the new value\n    </tablecell>\n    <tablecell>i = 5; j = ++i</tablecell>\n    <tablecell classname=\"text-right\">i = 6, j = 6</tablecell>\n  </tablerow>\n  <tablerow>\n    <tablecell classname=\"font-medium\">i--</tablecell>\n    <tablecell>\n      post-decrement: returns current value, then decreases by 1\n    </tablecell>\n    <tablecell>i = 5; j = i--</tablecell>\n    <tablecell classname=\"text-right\">i = 4, j = 5</tablecell>\n  </tablerow>\n  <tablerow>\n    <tablecell classname=\"font-medium\">--i</tablecell>\n    <tablecell>\n      pre-decrement: decreases by 1, then returns the new value\n    </tablecell>\n    <tablecell>i = 5; j = --i</tablecell>\n    <tablecell classname=\"text-right\">i = 4, j = 4</tablecell>\n  </tablerow>\n</tablebody> </table> notes: > - works only on mutable lvalues; using on constants or rvalues should be a compile error.\n> - avoid relying on multiple increments of the same variable within a single expression if your language disallows/diagnoses unspecified order of evaluation. <br /> ## null-coalescing operator the null-coalescing operator (||) is used with pointers to select the first non-null value from a chain of operands.  \nit evaluates operands from left to right and returns the first pointer that is not null.  \nif all operands are null, the result is null.",
    "language": "en",
    "category": "tutorial",
    "weight": 4
  },
  {
    "id": "en-faq-faq",
    "title": "FAQ",
    "path": "/en/docs/faq/faq",
    "content": "...",
    "searchable": "faq ... ",
    "language": "en",
    "category": "faq",
    "weight": 4
  },
  {
    "id": "en-getting-started-getting-started",
    "title": "Getting Started",
    "path": "/en/docs/getting-started/getting-started",
    "content": "...",
    "searchable": "getting started ... ",
    "language": "en",
    "category": "getting-started",
    "weight": 4
  },
  {
    "id": "en-getting-started-introduction",
    "title": "Introduction",
    "path": "/en/docs/getting-started/introduction",
    "content": "Welcome to the official documentation for Cyrus. Here you'll find everything you need to get started with our modern, expressive, and efficient programming language.",
    "searchable": "introduction welcome to the official documentation for cyrus. here you'll find everything you need to get started with our modern, expressive, and efficient programming language. <underdevelopmentalert title=\"under development\" /> # documentation welcome to the official documentation for cyrus. here you'll find everything you need to get started with our modern, expressive, and efficient programming language. cyrus is designed for developers who want the power of low-level control without sacrificing clarity. its syntax is concise and approachable, while its compiler ensures performance and safety through modern optimizations. whether you’re building high-performance systems, experimenting with algorithms, or exploring creative projects, cyrus gives you the tools to express ideas cleanly and run them efficiently. <br /> ### why cyrus? - expressiveness - code should feel natural to read and write, without unnecessary ceremony.\n- performance - the compiler generates optimized native code, making cyrus suitable for demanding workloads.\n- simplicity - a small but powerful core, with a standard library that grows with your needs, not against them. <br /> ## a quick taste here's a glimpse of what cyrus code looks like: <br /> <div classname=\"flex flex-col md:flex-row gap-4\">\n  <card classname=\"shadow-lg h-full\">\n    <cardheader>\n      <cardtitle classname=\"flex items-center gap-2 text-xl md:text-2xl\">\n        for newcomers\n      </cardtitle>\n    </cardheader>\n    <cardcontent>\n      <div classname=\"space-y-4\">\n        <div classname=\"text-base md:text-lg text-gray-600 dark:text-muted-foreground\">\n          if you're new to cyrus, start with our comprehensive tutorial to learn\n          the basics and progress quickly.\n        </div>\n        <link href=\"/docs/tutorial/basic-syntax\" classname=\"mt-2 block\">\n          <button classname=\"w-full md:w-auto\">get started</button>\n        </link>\n      </div>\n    </cardcontent>\n  </card>   <card classname=\"shadow-lg h-full\">\n    <cardheader>\n      <cardtitle classname=\"flex items-center gap-2 text-xl md:text-2xl\">\n        language reference\n      </cardtitle>\n    </cardheader>\n    <cardcontent>\n      <div classname=\"space-y-4\">\n        <div classname=\"text-base md:text-lg text-gray-600 dark:text-muted-foreground\">\n          explore our language reference for detailed information about built-in\n          types, functions, and modules in cyrus.\n        </div>\n        <link href=\"/docs/langref\" classname=\"mt-2 block\">\n          <button variant=\"outline\" classname=\"w-full md:w-auto\">\n            explore reference\n          </button>\n        </link>\n      </div>\n    </cardcontent>\n  </card>\n</div>",
    "language": "en",
    "category": "getting-started",
    "weight": 4
  },
  {
    "id": "en-getting-started-roadmap",
    "title": "Roadmap",
    "path": "/en/docs/getting-started/roadmap",
    "content": "Stay up to date with the Cyrus compiler development! Our public roadmap tracks every milestone, feature, and improvement as we evolve the language.",
    "searchable": "roadmap stay up to date with the cyrus compiler development! our public roadmap tracks every milestone, feature, and improvement as we evolve the language. # roadmap stay up to date with the **cyrus compiler development**! our public roadmap tracks every milestone, feature, and improvement as we evolve the language. below are the three main areas of focus for cyrus: --- ## 1. initial compiler the initial compiler is the foundation of cyrus. it includes the basic syntax, parsing, and core language features. this phase ensures that the language is **stable, performant, and ready for early experiments**.   check out the full initial compiler roadmap on github:   <link href=\"https://github.com/orgs/cyrus-lang/projects/1/views/1\" classname=\"text-primary\">\n    cyrus initial compiler roadmap\n</link> --- ## 2. self-hosted compiler the self-hosted compiler is the next step, where cyrus is capable of compiling **itself**. this milestone is critical for testing the language in **real-world scenarios** and improving compiler optimizations.   explore the self-hosted compiler plans here:   <link href=\"#\" classname=\"text-muted cursor-not-allowed\">\n    cyrus self-hosted compiler roadmap\n</link> --- ## 3. standard library the standard library provides **essential data structures, utilities, and apis** for developers. this phase ensures that cyrus can support **practical programming tasks** while maintaining **clarity, performance, and safety**.   view the standard library roadmap here:   <link href=\"#\" classname=\"text-muted cursor-not-allowed\">\n    cyrus standard library roadmap\n</link> --- you'll find what's **planned, in progress, and completed**, giving you a transparent view of how cyrus is evolving.",
    "language": "en",
    "category": "getting-started",
    "weight": 4
  },
  {
    "id": "en-tutorial-tutorial",
    "title": "Tutorial",
    "path": "/en/docs/tutorial/tutorial",
    "content": "...",
    "searchable": "tutorial ... ",
    "language": "en",
    "category": "tutorial",
    "weight": 4
  },
  {
    "id": "en-tutorial-variables",
    "title": "Variables",
    "path": "/en/docs/tutorial/variables",
    "content": "Global variables are declared at top-level. They may be private (no pub) or public (pub). Use var for mutable globals, const for immutable globals, and extern to declare symbols provided externally (no initializer).",
    "searchable": "variables global variables are declared at top-level. they may be private (no pub) or public (pub). use var for mutable globals, const for immutable globals, and extern to declare symbols provided externally (no initializer). # global variables global variables are declared at top-level. they may be **private** (no pub) or **public** (pub). use var for mutable globals, const for immutable globals, and extern to declare symbols provided externally (no initializer). * **var**: mutable global (initializer optional; zero-initialized if omitted).\n* **const**: immutable global (must be initialized at declaration).\n* **extern**: declares a symbol provided by the runtime/linker. examples: reassignment rules: --- ## local variables local variables inside functions are declared using var or const. examples: --- ## zero initialization variables (both globals and locals) declared without an initializer are automatically zero-initialized:",
    "language": "en",
    "category": "tutorial",
    "weight": 4
  },
  {
    "id": "fa-getting-started-introduction",
    "title": "معرفی",
    "path": "/fa/docs/getting-started/introduction",
    "content": "به مستندات رسمی سایروس خوش آمدید. در اینجا همه چیزهایی که برای شروع با زبان برنامه‌نویسی مدرن، بیانگر و کارآمد ما نیاز دارید را پیدا خواهید کرد.",
    "searchable": "معرفی به مستندات رسمی سایروس خوش آمدید. در اینجا همه چیزهایی که برای شروع با زبان برنامه‌نویسی مدرن، بیانگر و کارآمد ما نیاز دارید را پیدا خواهید کرد. <erroralert title=\"در حال توسعه\" /> # مستندات به مستندات رسمی سایروس خوش آمدید. در اینجا همه چیزهایی که برای شروع با زبان برنامه‌نویسی مدرن، بیانگر و کارآمد ما نیاز دارید را پیدا خواهید کرد. <br /> <div classname=\"flex flex-col md:flex-row gap-4\">\n  <card classname=\"shadow-lg h-full\">\n    <cardheader>\n      <cardtitle classname=\"flex items-center gap-2 text-xl md:text-2xl\">\n        برای تازه‌واردان\n      </cardtitle>\n    </cardheader>\n    <cardcontent>\n      <div classname=\"space-y-4\">\n        <div classname=\"text-base md:text-lg text-gray-600 dark:text-muted-foreground\">\n          اگر تازه با سایروس آشنا شده‌اید، با آموزش جامع ما شروع کنید تا اصول\n          اولیه را یاد بگیرید و سریعاً پیشرفت کنید.\n        </div>\n        <link href=\"/docs/tutorial/basic-syntax\" classname=\"mt-2 block\">\n          <button classname=\"w-full md:w-auto\">شروع کنید</button>\n        </link>\n      </div>\n    </cardcontent>\n  </card>   <card classname=\"shadow-lg h-full\">\n    <cardheader>\n      <cardtitle classname=\"flex items-center gap-2 text-xl md:text-2xl\">\n        مرجع زبان\n      </cardtitle>\n    </cardheader>\n    <cardcontent>\n      <div classname=\"space-y-4\">\n        <div classname=\"text-base md:text-lg text-gray-600 dark:text-muted-foreground\">\n          برای بررسی دقیق انواع داخلی، توابع و ماژول‌های سایروس، مرجع زبان ما را\n          بررسی کنید.\n        </div>\n        <link href=\"/docs/langref\" classname=\"mt-2 block\">\n          <button variant=\"outline\" classname=\"w-full md:w-auto\">\n            مشاهده مرجع\n          </button>\n        </link>\n      </div>\n    </cardcontent>\n  </card>\n</div>{\" \"}",
    "language": "fa",
    "category": "getting-started",
    "weight": 4
  },
  {
    "id": "fa-tutorial-installation",
    "title": "نصب",
    "path": "/fa/docs/tutorial/installation",
    "content": "قبل از شروع آموزش، باید سایروس را نصب کنید.",
    "searchable": "نصب قبل از شروع آموزش، باید سایروس را نصب کنید. # نصب سایروس قبل از شروع آموزش، باید سایروس را نصب کنید. ## روش‌های نصب ### 1. نصب مستقیم ### 2. استفاده از پکیج منیجر **ویندوز:** **لینوکس:** **مک:** ## تأیید نصب باید خروجی مشابه این ببینید:",
    "language": "fa",
    "category": "tutorial",
    "weight": 4
  },
  {
    "id": "en-getting-started-design-goals",
    "title": "Design Goals",
    "path": "/en/docs/getting-started/design-goals",
    "content": "Cyrus is a mid-level, imperative programming language designed for developers who want modern power without modern complexity.",
    "searchable": "design goals cyrus is a mid-level, imperative programming language designed for developers who want modern power without modern complexity. # cyrus programming language cyrus is a mid-level, imperative programming language designed for developers who want modern power without modern complexity. it is built with performance and clarity in mind, featuring a lightweight memory model, zero runtime dependency, and a clean, expressive syntax designed from scratch. if you are familiar with c, go, you’ll feel right at home — and probably happier. --- ## ✨ key philosophy cyrus was born out of frustration with the unnecessary complexity of modern languages. while languages like rust and go offer great features, they also come with learning curves, runtimes, or abstractions that many system programmers neither need nor want. cyrus makes a different bet: that **simplicity, explicitness, and elegance** can coexist without sacrificing performance. --- ## 🚀 features ### 🧠 syntax-first simplicity - designed from scratch for **maximum readability and minimal cognitive load**.\n- not a c clone, but friendly to c-style minds.\n- no \"magic,\" no hidden transformations, no obscure rules. ### ⚙️ memory management - **no garbage collector**.\n- uses **custom allocator objects** and **lifetime zones** for memory grouping and release.\n- allows deterministic control without the steep complexity of ownership models like rust.\n- designed for **compile-time safety**, with minimal runtime involvement. ### 🔩 low-level control - full control over system memory and stack.\n- optional inline assembly support.\n- safe by default, but unsafe blocks allow full access when necessary. ### 📦 module system - clean, expressive module system.\n- no build tool hell — just readable imports and clean dependency handling. ### 🛠 built on llvm - high-performance llvm backend.\n- compiles to efficient native code.\n- supports cross-compilation and future toolchain integration. ### 🔄 concurrency support (we still thinking about the idea...) - language-level support for concurrency — without needing a runtime.\n- based on allocators and resource ownership patterns that work well in parallel contexts. --- ## 👤 who is cyrus for? cyrus is ideal for: - system developers who love **c**, but want a modern evolution without garbage collection.\n- developers frustrated by the **learning curve of rust**, but who still want safe and performant code.\n- embedded and os-level developers needing **low runtime overhead and full control**.\n- anyone looking for a beautiful, expressive, **low-level language that respects your brain**. not recommended (yet) for: - absolute beginners with no background in system languages.\n- developers who want automatic memory management and runtime safety without learning allocator logic. --- ## 🧪 current status cyrus is in active development and rapidly evolving. for a detailed overview of our planned features and development timeline, please refer to our public roadmap listed in the [github project](https://github.com/orgs/cyrus-lang/projects/1). --- ## 📚 philosophy - **simplicity is a feature.**\n- **readability is performance.**\n- **performance is non-negotiable.**\n- **you, the developer, are in control.**",
    "language": "en",
    "category": "getting-started",
    "weight": 3
  },
  {
    "id": "en-tutorial-types",
    "title": "Types",
    "path": "/en/docs/tutorial/types",
    "content": "Cyrus features a strong and expressive type system. The compiler performs implicit type conversions when it is safe, and requires explicit casts when conversions could be unsafe or lossy.",
    "searchable": "types cyrus features a strong and expressive type system. the compiler performs implicit type conversions when it is safe, and requires explicit casts when conversions could be unsafe or lossy. # type system cyrus features a **strong and expressive type system**. the compiler performs **implicit type conversions** when it is safe, and requires **explicit casts** when conversions could be unsafe or lossy. <br /> ## safe implicit casting if a type can be safely converted to another type without losing information, cyrus will perform the conversion automatically.   - int32 (32-bit signed integer) can always fit into int64 (64-bit signed integer).  \n- the compiler handles this **implicitly**, so no special syntax is required.  \n- safe casts also apply to numeric literals, e.g., #x: float64 = 10.0 is allowed. <br /> ## unsafe / explicit casting if a conversion **could be unsafe**, the compiler requires an **explicit cast** using the cast keyword. <br /> # basic types cyrus provides a set of built-in types for numbers, characters, booleans, and special-purpose values. these are the fundamental building blocks of your programs. <table>\n  <tableheader>\n    <tablerow>\n      <tablehead classname=\"w-[160px]\">type</tablehead>\n      <tablehead>category</tablehead>\n      <tablehead>bit width</tablehead>\n      <tablehead classname=\"text-right\">signedness</tablehead>\n    </tablerow>\n  </tableheader>\n  <tablebody>\n    <tablerow>\n      <tablecell classname=\"font-medium\">int</tablecell>\n      <tablecell>signed integer (default)</tablecell>\n      <tablecell>target-dependent (usually 32 or 64)</tablecell>\n      <tablecell classname=\"text-right\">signed</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">int8</tablecell>\n      <tablecell>signed integer</tablecell>\n      <tablecell>8</tablecell>\n      <tablecell classname=\"text-right\">signed</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">int16</tablecell>\n      <tablecell>signed integer</tablecell>\n      <tablecell>16</tablecell>\n      <tablecell classname=\"text-right\">signed</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">int32</tablecell>\n      <tablecell>signed integer</tablecell>\n      <tablecell>32</tablecell>\n      <tablecell classname=\"text-right\">signed</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">int64</tablecell>\n      <tablecell>signed integer</tablecell>\n      <tablecell>64</tablecell>\n      <tablecell classname=\"text-right\">signed</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">int128</tablecell>\n      <tablecell>signed integer</tablecell>\n      <tablecell>128</tablecell>\n      <tablecell classname=\"text-right\">signed</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">uint</tablecell>\n      <tablecell>unsigned integer (default)</tablecell>\n      <tablecell>target-dependent (usually 32 or 64)</tablecell>\n      <tablecell classname=\"text-right\">unsigned</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">uint8</tablecell>\n      <tablecell>unsigned integer</tablecell>\n      <tablecell>8</tablecell>\n      <tablecell classname=\"text-right\">unsigned</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">uint16</tablecell>\n      <tablecell>unsigned integer</tablecell>\n      <tablecell>16</tablecell>\n      <tablecell classname=\"text-right\">unsigned</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">uint32</tablecell>\n      <tablecell>unsigned integer</tablecell>\n      <tablecell>32</tablecell>\n      <tablecell classname=\"text-right\">unsigned</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">uint64</tablecell>\n      <tablecell>unsigned integer</tablecell>\n      <tablecell>64</tablecell>\n      <tablecell classname=\"text-right\">unsigned</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">uint128</tablecell>\n      <tablecell>unsigned integer</tablecell>\n      <tablecell>128</tablecell>\n      <tablecell classname=\"text-right\">unsigned</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">intptr</tablecell>\n      <tablecell>pointer-sized integer</tablecell>\n      <tablecell>pointer width (32 or 64)</tablecell>\n      <tablecell classname=\"text-right\">signed</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">uintptr</tablecell>\n      <tablecell>pointer-sized integer</tablecell>\n      <tablecell>pointer width (32 or 64)</tablecell>\n      <tablecell classname=\"text-right\">unsigned</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">size_t</tablecell>\n      <tablecell>size / index type</tablecell>\n      <tablecell>pointer width (32 or 64)</tablecell>\n      <tablecell classname=\"text-right\">unsigned</tablecell>\n    </tablerow>\n  </tablebody>\n</table> <br /> ### floating-point types <table>\n  <tableheader>\n    <tablerow>\n      <tablehead classname=\"w-[150px]\">type</tablehead>\n      <tablehead>description</tablehead>\n      <tablehead classname=\"text-right\">precision</tablehead>\n    </tablerow>\n  </tableheader>\n  <tablebody>\n    <tablerow>\n      <tablecell classname=\"font-medium\">float16</tablecell>\n      <tablecell>16-bit floating-point number (half precision)</tablecell>\n      <tablecell classname=\"text-right\">~3 decimal digits</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">float32</tablecell>\n      <tablecell>32-bit floating-point number (single precision)</tablecell>\n      <tablecell classname=\"text-right\">~7 decimal digits</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">float64</tablecell>\n      <tablecell>64-bit floating-point number (double precision)</tablecell>\n      <tablecell classname=\"text-right\">~15–16 decimal digits</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">float128</tablecell>\n      <tablecell>128-bit floating-point number (quadruple precision)</tablecell>\n      <tablecell classname=\"text-right\">~34 decimal digits</tablecell>\n    </tablerow>\n  </tablebody>\n</table> <br /> ### character and boolean types <table>\n  <tableheader>\n    <tablerow>\n      <tablehead classname=\"w-[150px]\">type</tablehead>\n      <tablehead>description</tablehead>\n      <tablehead classname=\"text-right\">notes</tablehead>\n    </tablerow>\n  </tableheader>\n  <tablebody>\n    <tablerow>\n      <tablecell classname=\"font-medium\">char</tablecell>\n      <tablecell>a single character unit (one code unit; multi-byte unicode not allowed in '...').</tablecell>\n      <tablecell classname=\"text-right\">represents ascii/byte chars only</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">bool</tablecell>\n      <tablecell>boolean values, either <code>true</code> or <code>false</code>.</tablecell>\n      <tablecell classname=\"text-right\">1-bit storage (typically padded to 8 bits)</tablecell>\n    </tablerow>\n  </tablebody>\n</table> <br /> ### special types <table>\n  <tableheader>\n    <tablerow>\n      <tablehead classname=\"w-[150px]\">type</tablehead>\n      <tablehead>description</tablehead>\n      <tablehead classname=\"text-right\">notes</tablehead>\n    </tablerow>\n  </tableheader>\n  <tablebody>\n     <tablerow>\n      <tablecell classname=\"font-medium\">void</tablecell>\n      <tablecell>represents no value, commonly used for functions that do not return anything.</tablecell>\n      <tablecell classname=\"text-right\">return type only</tablecell>\n    </tablerow>\n  </tablebody>\n</table>",
    "language": "en",
    "category": "tutorial",
    "weight": 3
  },
  {
    "id": "fa-tutorial-tutorial",
    "title": "آموزش",
    "path": "/fa/docs/tutorial/tutorial",
    "content": "این بخش شامل آموزش‌های کامل برای یادگیری زبان برنامه‌نویسی سایروس است.",
    "searchable": "آموزش این بخش شامل آموزش‌های کامل برای یادگیری زبان برنامه‌نویسی سایروس است. # آموزش سایروس این بخش شامل آموزش‌های کامل برای یادگیری زبان برنامه‌نویسی سایروس است.",
    "language": "fa",
    "category": "tutorial",
    "weight": 3
  },
  {
    "id": "fa-getting-started-design-goals",
    "title": "اهداف طراحی",
    "path": "/fa/docs/getting-started/design-goals",
    "content": "سایروس یک زبان برنامه‌نویسی سطح میانی و Imperative است که برای توسعه‌دهندگانی طراحی شده که به دنبال قدرت مدرن هستند، اما تمایلی به پیچیدگی‌های مدرن ندارند.",
    "searchable": "اهداف طراحی سایروس یک زبان برنامه‌نویسی سطح میانی و imperative است که برای توسعه‌دهندگانی طراحی شده که به دنبال قدرت مدرن هستند، اما تمایلی به پیچیدگی‌های مدرن ندارند. # زبان برنامه‌نویسی سایروس سایروس یک زبان برنامه‌نویسی سطح میانی و imperative است که برای توسعه‌دهندگانی طراحی شده که به دنبال قدرت مدرن هستند، اما تمایلی به پیچیدگی‌های مدرن ندارند. این زبان با تمرکز بر عملکرد بالا و وضوح طراحی شده است. دارای یک مدل حافظه سبک، بدون وابستگی به رانتایم، و نگارشی ساده و ابداعی است. اگر با زبان‌هایی مانند c یا go آشنایی داشته باشید، سایروس برایتان محیطی آشنا و حتی لذت‌بخش‌تر خواهد بود. --- ## ✨ فلسفه‌ی اصلی سایروس از دل نارضایتی از پیچیدگی بی‌مورد زبان‌های برنامه‌نویسی مدرن زاده شد. گرچه زبان‌هایی مانند rust و go قابلیت‌های زیادی دارند، اما همراه آن‌ها منحنی یادگیری، پیچیدگی رانتایم، یا انتزاعاتی ارائه می‌شود که بسیاری از برنامه‌نویسان سیستم واقعاً نیازی به آن‌ها ندارند. سایروس بر پایه‌ی این فرض بنا شده که **سادگی، صراحت، و زیبایی** می‌توانند در کنار هم وجود داشته باشند؛ بدون آن‌که چیزی از عملکرد کاسته شود. --- ## 🚀 ویژگی‌ها ### 🧠 سادگی مبتنی بر سینتکس - از پایه با هدف **حداکثر خوانایی و حداقل بار ذهنی** طراحی شده است.\n- کلونی از c نیست، اما برای ذهن‌هایی که به سبک c فکر می‌کنند بسیار آشنا خواهد بود.\n- بدون جادوی پنهان، بدون تبدیل‌های نامرئی، و بدون قواعد پیچیده و غیرقابل درک. ### ⚙️ مدیریت حافظه - **بدون استفاده از گاربج کالکتور (gc)**.\n- بهره‌گیری از **ابجکت‌های الوکیتر سفارشی** و **محدوده‌های طول عمر (lifetime zones)** برای گروه‌بندی و آزادسازی حافظه.\n- کنترل کاملاً پیش‌بینی‌پذیر و بدون مدل‌های پیچیده‌ی مالکیت مانند rust.\n- طراحی‌شده با هدف **بررسی ایمنی در زمان کامپایل** و دخالت حداقلی در زمان اجرا. ### 🔩 کنترل سطح پایین - دسترسی و کنترل کامل بر حافظه سیستم و پشته (stack).\n- پشتیبانی اختیاری از اسمبلی خطی (inline assembly).\n- به‌صورت پیش‌فرض ایمن است، اما در صورت نیاز می‌توان با استفاده از بلوک‌های unsafe به تمام امکانات دسترسی داشت. ### 📦 سیستم ماژول زیبا و شفاف - سیستم ماژول تمیز، گویا، و خوانا.\n- بدون نیاز به ابزارهای پیچیده ساخت و ساز (build tools)، فقط ایمپورت‌های ساده و کنترل وابستگی واضح. ### 🛠 مبتنی بر llvm - بک‌اند قدرتمند مبتنی بر llvm.\n- تبدیل مستقیم به کد باینری سریع و کارآمد.\n- پشتیبانی از کامپایل متقابل (cross-compilation) و یکپارچه‌سازی با ابزارهای آینده. ### 🔄 پشتیبانی از هم‌زمانی (در حال بررسی و طراحی) - پشتیبانی در سطح زبان برای هم‌زمانی، بدون نیاز به رانتایم.\n- مبتنی بر الگوهای مالکیت و مدیریت منابع که در زمینه‌ی هم‌زمانی نیز کاربرد دارند. --- ## 👤 این زبان برای چه کسانی طراحی شده است؟ سایروس مناسب است برای: - توسعه‌دهندگان سیستم که عاشق **c** هستند ولی به‌دنبال نسخه‌ای مدرن و بدون gc هستند.\n- برنامه‌نویسانی که از **منحنی یادگیری rust** خسته شده‌اند ولی همچنان به دنبال امنیت حافظه و عملکرد بالا هستند.\n- توسعه‌دهندگان سطح پایین یا امبدد (embedded/os) که نیاز به **رانتایم سبک و کنترل کامل بر سخت‌افزار** دارند.\n- هر کسی که به‌دنبال زبانی سطح پایین، زیبا و خوانا است که به شعور او احترام می‌گذارد. فعلاً پیشنهاد نمی‌شود برای: - افراد کاملاً مبتدی که تجربه‌ای در زبان‌های سطح پایین ندارند.\n- توسعه‌دهندگانی که به دنبال مدیریت حافظه خودکار و ایمنی رانتایم بدون آشنایی با الگوهای تخصیص حافظه هستند. --- ## 🧪 وضعیت فعلی زبان سایروس در حال توسعه فعال است و با سرعت در حال رشد است. برای مشاهده نقشه راه کامل توسعه، لطفاً به [پروژه رسمی ما در گیت‌هاب](https://github.com/orgs/cyrus-lang/projects/1) مراجعه کنید. --- ## 📚 باورهای طراحی - **سادگی، یک قابلیت است.**\n- **خوانایی، بخشی از عملکرد است.**\n- **عملکرد، غیرقابل مذاکره است.**\n- **کنترل باید در دستان برنامه‌نویس باشد.**",
    "language": "fa",
    "category": "getting-started",
    "weight": 3
  },
  {
    "id": "fa-tutorial-basic-syntax",
    "title": "نحو پایه",
    "path": "/fa/docs/tutorial/basic-syntax",
    "content": "سایروس دارای نحو ساده و قابل فهمی است که یادگیری آن آسان است.",
    "searchable": "نحو پایه سایروس دارای نحو ساده و قابل فهمی است که یادگیری آن آسان است. # نحو پایه سایروس دارای نحو ساده و قابل فهمی است که یادگیری آن آسان است. ## توضیحات ## ثابت‌ها ## کاراکترهای فرار ## انواع پایه ## ثابت‌های عددی ## آرایه‌ها ## بردارها ## اشاره‌گرها",
    "language": "fa",
    "category": "tutorial",
    "weight": 3
  },
  {
    "id": "en-tutorial-basic-syntax",
    "title": "Basic Syntax",
    "path": "/en/docs/tutorial/basic-syntax",
    "content": "This article is an introduction to the Cyrus Programming Language. It assumes you already have a basic understanding of programming concepts such as variables, statements, and types. Here, you’ll see how familiar ideas are expressed in Cyrus, while also being introduced to new concepts that make the language unique.",
    "searchable": "basic syntax this article is an introduction to the cyrus programming language. it assumes you already have a basic understanding of programming concepts such as variables, statements, and types. here, you’ll see how familiar ideas are expressed in cyrus, while also being introduced to new concepts that make the language unique. # basic syntax this article is an introduction to the cyrus programming language. it assumes you already have a basic understanding of programming concepts such as variables, statements, and types. here, you’ll see how familiar ideas are expressed in cyrus, while also being introduced to new concepts that make the language unique. if you haven't installed cyrus yet, start with the [getting started](/en/docs/getting-started/install-compiler-binary) guide before continuing. <br /> ## comments comments are pieces of text ignored by the compiler.\nthey're useful for explaining code, leaving notes, or temporarily disabling parts of a program. cyrus supports both single-line and multi-line comments. - single-line comments - multi-line comments <br /> ## const string and character literals string literals in cyrus are enclosed in double quotes **\"xxx\"**, while character literals are enclosed in single quotes **'x'**.\nboth forms represent sequences of unicode characters, but they differ in intent and usage: - string literals produce values of type **char\\***, which can hold arbitrarily many characters.\n- character literals produce values of type **char**, which always represent exactly one unicode scalar value. ### escapes special characters that are difficult to type directly or would otherwise break the syntax can be written using escape sequences. all escape sequences begin with a backslash (\\). common escapes include: - **\\n** - newline (line feed, u+000a)\n- **\\t** - horizontal tab (u+0009)\n- **\\r** - carriage return (u+000d)\n- **\\b** - backspace (u+0008)\n- **\\a** - bell/alert (u+0007)\n- **\\v** - vertical tab (u+000b)\n- **\\f** - form feed (u+000c)\n- **\\\\** - literal backslash\n- **\\\"** - double quote (inside strings)\n- **\\'** - single quote (inside chars or strings) example: <br /> ### unicode and emojis cyrus supports unicode characters directly in string and character literals. you can type emojis, accented letters, or any other unicode characters inside quotes: <br /> ## integer constants numeric constants in cyrus can be written in **decimal**, **hexadecimal**, **octal**, or **binary** formats: - decimal (base 10): - hexadecimal (base 16, prefix with 0x or 0x): - binary (base 2, prefix with 0b or 0b): numeric literals may include underscores **\\_** between digits for readability; these are ignored by the compiler: <br /> ## literal suffixes cyrus allows explicit type suffixes on numeric literals to specify their type.\nthis is useful when the compiler cannot infer the type or when you want to guarantee a specific type. ### integer suffixes valid integer suffixes include: - uintptr\n- intptr\n- size_t\n- int\n- int8\n- int16\n- int32\n- int64\n- int128\n- uint\n- uint8\n- uint16\n- uint32\n- uint64\n- uint128 valid float suffixes include: - float16\n- float32\n- float64\n- float128 example: <br /> ### default type of literals if you don't specify a type suffix, cyrus assigns **int** as the default type for integer literals, and **float64** as the default type for floating-point literals. type suffixes can be used to explicitly control the size and signedness of an integer literal, or to select a different floating-point precision. <br /> ## arrays arrays in cyrus are fixed-size sequences of elements. their size must be known at compile time, similar to c arrays. example: - the array size cannot change at runtime.\n- access elements using indexing, starting from 0. <br /> ## pointers pointers in cyrus behave like c pointers. they store the memory address of another variable. - type\\* - pointer to a value of type\n- &variable - takes the address of a variable example: pointer arithmetic behaves like c (e.g., incrementing a pointer moves it by sizeof(type) bytes). <br /> ## vectors coming soon...",
    "language": "en",
    "category": "tutorial",
    "weight": 2
  },
  {
    "id": "en-faq-comparisons",
    "title": "Comparisons",
    "path": "/en/docs/faq/comparisons",
    "content": "Coming soon...",
    "searchable": "comparisons coming soon... # compare with other languages # c  coming soon... <br /> # rust  coming soon... <br /> # zig  coming soon...",
    "language": "en",
    "category": "faq",
    "weight": 2
  }
]