[
  {
    "id": "en-getting-started-build-from-source",
    "title": "Build from source",
    "path": "/en/docs/getting-started/build-from-source",
    "content": "Sometimes you want the freshest bits‚Äîwhether to contribute to Cyrus itself, test bleeding-edge features, or just peek under the compiler‚Äôs hood. Building from source is straightforward and gives you full control over the toolchain.",
    "searchable": "build from source # build from source sometimes you want the freshest bits‚Äîwhether to contribute to cyrus itself, test bleeding-edge features, or just peek under the compiler‚Äôs hood. building from source is straightforward and gives you full control over the toolchain. ### prerequisites before you begin, make sure you have the following installed: - git - to fetch the source code.\n- rust 1.87-nightly.\n- llvm 18. also these native libraries are required: - glibc\n- clang\n- clang-tools\n- libffi\n- ffi\n- ffi-dev\n- isl\n- libxml2 <br /> ## on linux update your package index first: ``\nsudo apt update\n``` install the dependencies: ```bash\nsudo apt install -y git \\\n    build-essential \\\n    clang \\\n    clang-tools \\\n    llvm-18 \\\n    llvm-18-dev \\\n    libffi-dev \\\n    libisl-dev \\\n    libxml2-dev \\\n    libc6-dev\n``` install rust using rustup: ```bash\ncurl --proto '=https' --tlsv1.2 -ssf https://sh.rustup.rs | sh\nsource $home/.cargo/env\nrustup toolchain install nightly-2025-01-01\nrustup default nightly-2025-01-01\n``` verify installation: ```bash\ngit --version\nrustc --version\nllvm-config --version\n``` <br /> ## macos (via homebrew): install dependencies via homebrew: ```bash\nbrew install git \\\n    llvm@18 \\\n    clang \\\n    libffi \\\n    isl \\\n    libxml2\n``` ensure homebrew‚Äôs llvm is in your path (add to ~/.zshrc or ~/.bashrc): ```bash\nexport path=\"/opt/homebrew/opt/llvm@18/bin:$path\"\n``` install rust using rustup: ```bash\ncurl --proto '=https' --tlsv1.2 -ssf https://sh.rustup.rs | sh\nsource $home/.cargo/env\nrustup toolchain install nightly-2025-01-01\nrustup default nightly-2025-01-01\n``` verify installation: ```bash\ngit --version\nrustc --version\nllvm-config --version\n``` <br /> ## on windows: coming soon... <br /> # clone the repository ```bash\ngit clone --depth=1 https://github.com/cyrus-lang/cyrus.git\ncd cyrus\n``` from the project root: ```bash\ncargo build -j24 \n``` this will produce the cyrus compiler binary in **target/release/cyrus**.",
    "language": "en",
    "category": "getting-started"
  },
  {
    "id": "en-getting-started-design-goals",
    "title": "Design Goals",
    "path": "/en/docs/getting-started/design-goals",
    "content": "Cyrus is a mid-level, imperative programming language designed for developers who want modern power without modern complexity.",
    "searchable": "design goals # cyrus programming language cyrus is a mid-level, imperative programming language designed for developers who want modern power without modern complexity. it is built with performance and clarity in mind, featuring a lightweight memory model, zero runtime dependency, and a clean, expressive syntax designed from scratch. if you are familiar with c, go, you‚Äôll feel right at home ‚Äî and probably happier. --- ## ‚ú® key philosophy cyrus was born out of frustration with the unnecessary complexity of modern languages. while languages like rust and go offer great features, they also come with learning curves, runtimes, or abstractions that many system programmers neither need nor want. cyrus makes a different bet: that *, explicitness, and elegance** can coexist without sacrificing performance. --- ## üöÄ features ### üß† syntax-first simplicity - designed from scratch for **maximum readability and minimal cognitive load**.\n- not a c clone, but friendly to c-style minds.\n- no \"magic,\" no hidden transformations, no obscure rules. ### ‚öôÔ∏è memory management - **no garbage collector**.\n- uses **custom allocator objects** and **lifetime zones** for memory grouping and release.\n- allows deterministic control without the steep complexity of ownership models like rust.\n- designed for **compile-time safety**, with minimal runtime involvement. ### üî© low-level control - full control over system memory and stack.\n- optional inline assembly support.\n- safe by default, but `unsafe` blocks allow full access when necessary. ### üì¶ module system - clean, expressive module system.\n- no build tool hell ‚Äî just readable imports and clean dependency handling. ### üõ† built on llvm - high-performance llvm backend.\n- compiles to efficient native code.\n- supports cross-compilation and future toolchain integration. ### üîÑ concurrency support (we still thinking about the idea...) - language-level support for concurrency ‚Äî without needing a runtime.\n- based on allocators and resource ownership patterns that work well in parallel contexts. --- ## üë§ who is cyrus for? cyrus is ideal for: - system developers who love **c**, but want a modern evolution without garbage collection.\n- developers frustrated by the **learning curve of rust**, but who still want safe and performant code.\n- embedded and os-level developers needing **low runtime overhead and full control**.\n- anyone looking for a beautiful, expressive, **low-level language that respects your brain**. not recommended (yet) for: - absolute beginners with no background in system languages.\n- developers who want automatic memory management and runtime safety without learning allocator logic. --- ## üß™ current status cyrus is in active development and rapidly evolving. for a detailed overview of our planned features and development timeline, please refer to our public roadmap listed in the [github project](https://github.com/orgs/cyrus-lang/projects/1). --- ## üìö philosophy - **simplicity is a feature.**\n- **readability is performance.**\n- **performance is non-negotiable.**\n- **you, the developer, are in control.**",
    "language": "en",
    "category": "getting-started"
  },
  {
    "id": "en-getting-started-getting-started",
    "title": "Getting Started",
    "path": "/en/docs/getting-started/getting-started",
    "content": "...",
    "searchable": "getting started ",
    "language": "en",
    "category": "getting-started"
  },
  {
    "id": "en-getting-started-hello-world",
    "title": "Hello World!",
    "path": "/en/docs/getting-started/hello-world",
    "content": "Let's start with the first program:",
    "searchable": "hello world! # hello cyrus! let's start with the first program: `` \nimport std::io; fn main() {\n    io::printfn(\"hello, cyrus\\n\");\n}\n``` <br /> ## compiling the program let's take the above program and put it in a file called **hello_world.cyr**. we can then run it with: ```bash\ncyrus run hello_world.cyr\n``` it should print hello, world! and return back to the command line prompt.",
    "language": "en",
    "category": "getting-started"
  },
  {
    "id": "en-getting-started-install-compiler-binary",
    "title": "Install compiler binary",
    "path": "/en/docs/getting-started/install-compiler-binary",
    "content": "Head over to the releases page and grab the archive for your platform:",
    "searchable": "install compiler binary # install compiler binary  cyrus provides prebuilt binaries for major platforms, available on our [github releases](https://github.com/cyrus-lang/cyrus/releases/) page. <br /> ## 1. download the latest release head over to the releases page and grab the archive for your platform: - linux (x86_64 / arm64)\n- windows (x86_64)\n- macos (intel / apple silicon) <br /> ## 2. extract the zip file after downloading the release archive from github releases, you need to extract it. so you can run cyrus from anywhere, move the binary to a directory in your path: ``\nsudo mv cyrus /usr/local/bin\n``` cyrus requires access to its standard library. copy it to a known location (e.g. ~/.cyrus_stdlib): ```bash\ncp -r ./stdlib ~/.cyrus_stdlib\n``` then export the path in your shell config (~/.bashrc, ~/.zshrc, etc.): ```bash\nexport cyrus_stdlib=~/.cyrus_stdlib\n``` apply the changes: ```bash\nsource ~/.bashrc # or source ~/.zshrc\n``` <br /> ## 3. verify the installation check the compiler works: ```bash\ncyrus version\n``` expected output:  ```bash\ncyrus vx.y.z\n```",
    "language": "en",
    "category": "getting-started"
  },
  {
    "id": "en-getting-started-introduction",
    "title": "Introduction",
    "path": "/en/docs/getting-started/introduction",
    "content": "Welcome to the official documentation for Cyrus. Here you'll find everything you need to get started with our modern, expressive, and efficient programming language.",
    "searchable": "introduction <underdevelopmentalert title=\"under development\" /> # documentation welcome to the official documentation for cyrus. here you'll find everything you need to get started with our modern, expressive, and efficient programming language. cyrus is designed for developers who want the power of low-level control without sacrificing clarity. its syntax is concise and approachable, while its compiler ensures performance and safety through modern optimizations. whether you‚Äôre building high-performance systems, experimenting with algorithms, or exploring creative projects, cyrus gives you the tools to express ideas cleanly and run them efficiently. <br /> ### why cyrus? - expressiveness - code should feel natural to read and write, without unnecessary ceremony.\n- performance - the compiler generates optimized native code, making cyrus suitable for demanding workloads.\n- simplicity - a small but powerful core, with a standard library that grows with your needs, not against them. <br /> ## a quick taste here's a glimpse of what cyrus code looks like: ``\nimport std::io; fn main() {\n  #msg: char* = \"hello, cyrus!\";\n  io::printfn(msg);\n}\n``` <br /> <div classname=\"flex flex-col md:flex-row gap-4\">\n  <card classname=\"shadow-lg h-full\">\n    <cardheader>\n      <cardtitle classname=\"flex items-center gap-2 text-xl md:text-2xl\">\n        for newcomers\n      </cardtitle>\n    </cardheader>\n    <cardcontent>\n      <div classname=\"space-y-4\">\n        <div classname=\"text-base md:text-lg text-gray-600 dark:text-muted-foreground\">\n          if you're new to cyrus, start with our comprehensive tutorial to learn\n          the basics and progress quickly.\n        </div>\n        <link href=\"/docs/tutorial/basic-syntax\" classname=\"mt-2 block\">\n          <button classname=\"w-full md:w-auto\">get started</button>\n        </link>\n      </div>\n    </cardcontent>\n  </card>   <card classname=\"shadow-lg h-full\">\n    <cardheader>\n      <cardtitle classname=\"flex items-center gap-2 text-xl md:text-2xl\">\n        language reference\n      </cardtitle>\n    </cardheader>\n    <cardcontent>\n      <div classname=\"space-y-4\">\n        <div classname=\"text-base md:text-lg text-gray-600 dark:text-muted-foreground\">\n          explore our language reference for detailed information about built-in\n          types, functions, and modules in cyrus.\n        </div>\n        <link href=\"/docs/langref\" classname=\"mt-2 block\">\n          <button variant=\"outline\" classname=\"w-full md:w-auto\">\n            explore reference\n          </button>\n        </link>\n      </div>\n    </cardcontent>\n  </card>\n</div>",
    "language": "en",
    "category": "getting-started"
  },
  {
    "id": "en-getting-started-roadmap",
    "title": "Roadmap",
    "path": "/en/docs/getting-started/roadmap",
    "content": "Stay up to date with the Cyrus compiler development! Our public roadmap tracks every milestone, feature, and improvement as we evolve the language.",
    "searchable": "roadmap # roadmap stay up to date with the * compiler development**! our public roadmap tracks every milestone, feature, and improvement as we evolve the language. below are the three main areas of focus for cyrus: --- ## 1. initial compiler the initial compiler is the foundation of cyrus. it includes the basic syntax, parsing, and core language features. this phase ensures that the language is **stable, performant, and ready for early experiments**.   check out the full initial compiler roadmap on github:   <link href=\"https://github.com/orgs/cyrus-lang/projects/1/views/1\" classname=\"text-primary\">\n    cyrus initial compiler roadmap\n</link> --- ## 2. self-hosted compiler the self-hosted compiler is the next step, where cyrus is capable of compiling **itself**. this milestone is critical for testing the language in **real-world scenarios** and improving compiler optimizations.   explore the self-hosted compiler plans here:   <link href=\"#\" classname=\"text-muted cursor-not-allowed\">\n    cyrus self-hosted compiler roadmap\n</link> --- ## 3. standard library the standard library provides **essential data structures, utilities, and apis** for developers. this phase ensures that cyrus can support **practical programming tasks** while maintaining **clarity, performance, and safety**.   view the standard library roadmap here:   <link href=\"#\" classname=\"text-muted cursor-not-allowed\">\n    cyrus standard library roadmap\n</link> --- you'll find what's **planned, in progress, and completed**, giving you a transparent view of how cyrus is evolving.",
    "language": "en",
    "category": "getting-started"
  },
  {
    "id": "en-tutorial-FFI",
    "title": "FFI",
    "path": "/en/docs/tutorial/FFI",
    "content": "Coming soon......",
    "searchable": "ffi coming soon...",
    "language": "en",
    "category": "tutorial"
  },
  {
    "id": "en-tutorial-basic-syntax",
    "title": "Basic Syntax",
    "path": "/en/docs/tutorial/basic-syntax",
    "content": "This article is an introduction to the Cyrus Programming Language. It assumes you already have a basic understanding of programming concepts such as variables, statements, and types. Here, you‚Äôll see how familiar ideas are expressed in Cyrus, while also being introduced to new concepts that make the language unique.",
    "searchable": "basic syntax # basic syntax this article is an introduction to the cyrus programming language. it assumes you already have a basic understanding of programming concepts such as variables, statements, and types. here, you‚Äôll see how familiar ideas are expressed in cyrus, while also being introduced to new concepts that make the language unique. if you haven't installed cyrus yet, start with the [getting started](/en/docs/getting-started/install-compiler-binary) guide before continuing. <br /> ## comments comments are pieces of text ignored by the compiler.\nthey're useful for explaining code, leaving notes, or temporarily disabling parts of a program. cyrus supports both single-line and multi-line comments. - single-line comments ``\n// this is a single-line comment\n#msg: char* = \"hello, cyrus!\"; // you can also place it after code\n``` - multi-line comments ```cyrus\n/*\n  outer comment start\n  /* nested comment inside */\n  outer comment end   note: multi-line comments can also be nested!\n*/\n``` <br /> ## const string and character literals string literals in cyrus are enclosed in double quotes **\"xxx\"**, while character literals are enclosed in single quotes **'x'**.\nboth forms represent sequences of unicode characters, but they differ in intent and usage: - string literals produce values of type **char\\***, which can hold arbitrarily many characters.\n- character literals produce values of type **char**, which always represent exactly one unicode scalar value. ```cyrus\n#greeting: char* = \"hello, cyrus!\";\n#letter: char = 'a';\n``` ### escapes special characters that are difficult to type directly or would otherwise break the syntax can be written using escape sequences. all escape sequences begin with a backslash (\\). common escapes include: - **\\n** - newline (line feed, u+000a)\n- **\\t** - horizontal tab (u+0009)\n- **\\r** - carriage return (u+000d)\n- **\\b** - backspace (u+0008)\n- **\\a** - bell/alert (u+0007)\n- **\\v** - vertical tab (u+000b)\n- **\\f** - form feed (u+000c)\n- **\\\\** - literal backslash\n- **\\\"** - double quote (inside strings)\n- **\\'** - single quote (inside chars or strings) example: ```cyrus\n#poem: char* = \"line one\\nline two\\nline three\";\n#quote: char* = \"she said: \\\"cyrus is great!\\\"\";\n#backslash: char = '\\\\'; #paragraph: char* = \"lorem ipsum is simply dummy text of the printing and typesetting industry.\nlorem ipsum has been the industry's standard dummy text ever since the 1500s,\nwhen an unknown printer took a galley of type and scrambled it to make a type specimen book.\";\n``` <br /> ### unicode and emojis cyrus supports unicode characters directly in string and character literals. you can type emojis, accented letters, or any other unicode characters inside quotes: ```cyrus\n#letter: char = 'a';                     // ‚úÖ works\n#smile: char* = \"üòá\";                    // ‚úÖ works in a string\n#rocket: string = \"let's go! \\u{1f680}\"; // ‚úÖ works, üöÄ\n#greek_alpha: char* = \"\\u03b1\";          // ‚úÖ works, Œ±\n#emoji_char: char = 'üòá';                // ‚ùå does not work\n#multibyte_char: char = '\\u263a';        // ‚ùå does not work\n``` <br /> ## integer constants numeric constants in cyrus can be written in **decimal**, **hexadecimal**, **octal**, or **binary** formats: - decimal (base 10): ```cyrus\n#a = 1234;\n``` - hexadecimal (base 16, prefix with 0x or 0x): ```cyrus\n#b = 0x42edaa02;\n``` - binary (base 2, prefix with 0b or 0b): ```cyrus\n#b = 0x42edaa02;\n``` numeric literals may include underscores **\\_** between digits for readability; these are ignored by the compiler: ```cyrus\n#million = 1_000_000;\n#hex_val = 0xde_ad_be_ef;\n``` <br /> ## literal suffixes cyrus allows explicit type suffixes on numeric literals to specify their type.\nthis is useful when the compiler cannot infer the type or when you want to guarantee a specific type. ### integer suffixes valid integer suffixes include: - uintptr\n- intptr\n- size_t\n- int\n- int8\n- int16\n- int32\n- int64\n- int128\n- uint\n- uint8\n- uint16\n- uint32\n- uint64\n- uint128 valid float suffixes include: - float16\n- float32\n- float64\n- float128 example: ```cyrus\n#a = 1234int64;\n#b = 3.14float64;\n``` <br /> ### default type of literals if you don't specify a type suffix, cyrus assigns **int** as the default type for integer literals, and **float64** as the default type for floating-point literals. type suffixes can be used to explicitly control the size and signedness of an integer literal, or to select a different floating-point precision. <br /> ## arrays arrays in cyrus are fixed-size sequences of elements. their size must be known at compile time, similar to c arrays. ```cyrus\n#name = type[capacity]{element1, element2, ..., elementn};\n``` example: ```cyrus\n#a = int[3]{1, 2, 3};\n#b = const float64[4]{3.14, 2.71, 1.618, 0.577};\n``` - the array size cannot change at runtime.\n- access elements using indexing, starting from 0. ```cyrus\nprintf(\"%d\\n\", a[0]);\n``` <br /> ## pointers pointers in cyrus behave like c pointers. they store the memory address of another variable. ```cyrus\n#ptr: type* = &variable;\n``` - type\\* - pointer to a value of type\n- &variable - takes the address of a variable example: ```cyrus\n#a: int = 10;\n#b: int* = &a; printf(\"%d\\n\", *b); // prints 10\n``` pointer arithmetic behaves like c (e.g., incrementing a pointer moves it by sizeof(type) bytes). <br /> ## vectors coming soon...",
    "language": "en",
    "category": "tutorial"
  },
  {
    "id": "en-tutorial-control-flow",
    "title": "Control Flow",
    "path": "/en/docs/tutorial/control-flow",
    "content": "Conditional statements let you execute different blocks of code depending on whether a condition evaluates to true or false. Conditions must evaluate to a bool value.",
    "searchable": "control flow ## conditional statements conditional statements let you execute different blocks of code depending on whether a condition evaluates to true or false. conditions must evaluate to a bool value. ``\nif (condition) {\n    // executes if condition is true\n} else {\n    // executes if condition is false\n}\n``` ```cyrus\nif (condition1) {\n    // executes if condition1 is true\n} else if (condition2) {\n    // executes if condition1 is false but condition2 is true\n} else {\n    // executes if all previous conditions are false\n}\n``` <br /> ## looping constructs a for loop allows repeating a block of code multiple times. it usually consists of three optional parts inside the loop header: - initializer - runs once before the loop begins (often used to declare and initialize a counter).\n- condition - checked before each iteration; if false, the loop exits.\n- increment/update - executed after each iteration. ```cyrus\nfor (initializer; condition; increment) {\n    // body\n}\n``` <br /> ### classic counter loop ```cyrus\nfor (#i = 0; i < 10; i++) {\n    // executes 10 times: i = 0..9\n}\n``` <br /> ### manual increment loop ```cyrus\nfor (#i = 0; i < 10;) {\n    // executes while i < 10\n    // you must manually increment i inside the body\n    i++;\n}\n``` here, the increment part is omitted. the loop continues until the condition becomes false, but you control when i is updated. <br /> ### conditionless loop with initializer ```cyrus\nfor (#i = 0;) {\n    // infinite unless you break manually\n    // no condition, no increment\n    if (i > 5) {\n        break; // stop after 6 iterations\n    }\n    i++;\n}\n``` only the initializer is given. since there‚Äôs no condition, the loop is infinite unless explicitly terminated with break or return. <br /> ### pure infinite loop ```cyrus\nfor {\n    // infinite loop with no initializer, no condition, no increment\n    // must be exited with break or return\n}\n``` <br /> ### while statement a while loop repeatedly executes a block of code as long as a condition evaluates to true. the condition is checked before each iteration. if the condition is false at the start, the loop body never runs. ```cyrus\nwhile (condition) {\n    // body\n}\n``` ```cyrus\n#i = 0; while (true) {\n    printf(\"v: %d\\n\", i);\n    i++;     if (i == 10) {\n        break; // exit when i reaches 10.\n    }\n}\n``` <br /> ## switch statement a switch statement allows execution to branch based on the value of an expression. it provides a concise way to compare against multiple possibilities without writing a long chain of if‚Äìelse if statements. ‚ö†Ô∏è note: this is not pattern matching. cases in cyrus are always compared against raw values, not structural patterns or conditions. <br /> ### basic form ```cyrus\n#i: int = 0; switch (i) {\n    case 0:\n        // this block runs if i is equal to 0.\n        break;     case 1:\n        // this block runs if i is equal to 1.\n        break;     default:\n        // this block runs if none of the above cases match.\n        break;\n}\n``` <br /> ### fallthrough behavior in cyrus, switch statements automatically fall through to the next case unless you explicitly use break.\nthis is the same behavior as in c and c++, and unlike languages such as go or rust where each case ends automatically. ```cyrus\n#i: int = 2; switch (i) {\n    case 2:\n        // runs when i == 2\n        // execution continues into the next case unless we break.\n    case 3:\n        // this also runs, because there was no break after case 2.\n        break;\n}\n``` <br /> ### enum variants switch statements can also match enum variants, but that will be explained in detail in the future on the enums page.",
    "language": "en",
    "category": "tutorial"
  },
  {
    "id": "en-tutorial-enums",
    "title": "Enums",
    "path": "/en/docs/tutorial/enums",
    "content": "Enums in Cyrus are a way to define a type that can hold one value out of a fixed set of variants. Each variant can be a simple tag, a tagged constant, or carry additional fields (like a struct).",
    "searchable": "enums # enums enums in cyrus are a way to define a type that can hold one value out of a fixed set of variants. each variant can be a simple tag, a tagged constant, or carry additional fields (like a struct). <br /> ## declaring an enum you declare an enum with the enum keyword, followed by its name and variant list: ``\nenum color {\n    red,\n    green,\n    black,\n    valued = \"my valued color!\",\n    custom(int, int, int)\n}\n``` <br /> ## using enums you construct enum values by qualifying them with the enum's name: ```cyrus\n#variant = color.red;\n#variant = color.valued;\n#variant = color.custom(1, 2, 3);\n``` <br /> ## matching enum variants the switch statement lets you match a value against the possible variants of an enum. each case corresponds to one variant. if the variant carries fields, you can bind them to local variables inside the case body: ```cyrus\nswitch (variant) {\n    case .red:\n        printf(\"red\\n\");\n        break;\n    case .black:\n        printf(\"black\\n\");\n        break;\n    case .valued:\n        printf(\"valued\\n\");\n        break;\n    case .custom(a, b, c):\n        printf(\"color(%d, %d, %d)\\n\", a, b, c);\n        break;\n    default:\n        printf(\"unknown\\n\");\n        break;\n}\n``` <br /> ## fallthrough into enum variants with fields when a case without fields falls through into a case with fields, the compiler must attempt to bind payload variables for the second case. since the actual variant does not contain those fields, the bindings would be undefined, which could lead to undefined behavior at runtime. the compiler will not allow this. if a programmer attempts to write a switch where a fieldless case falls through into a case with fields, the compiler will produce an error, forcing the developer to either terminate the first case with break; or explicitly handle fallthrough safely. ```cyrus\n switch (variant) {\n    case .red:\n        printf(\"red chosen!\\n\");\n        // missing `break;`\n    case .custom(a, b, c):\n        printf(\"custom(%d, %d, %d)\\n\", a, b, c);\n        break;\n}\n```",
    "language": "en",
    "category": "tutorial"
  },
  {
    "id": "en-tutorial-error_handling",
    "title": "Error Handling",
    "path": "/en/docs/tutorial/error_handling",
    "content": "Coming soon......",
    "searchable": "error handling coming soon...",
    "language": "en",
    "category": "tutorial"
  },
  {
    "id": "en-tutorial-expressions",
    "title": "Expressions",
    "path": "/en/docs/tutorial/expressions",
    "content": "Operators in Cyrus work similarly to those in C. They are categorized by their functionality and precedence.",
    "searchable": "expressions # operators operators in cyrus work similarly to those in c. they are categorized by their functionality and precedence.\noperators are evaluated based on their precedence (priority) and associativity (left-to-right or right-to-left). <br /> ## arithmetic operators arithmetic operators perform mathematical calculations between numeric operands. <table>\n  <tableheader>\n    <tablerow>\n      <tablehead classname=\"w-[100px]\">operator</tablehead>\n      <tablehead>meaning</tablehead>\n      <tablehead>example</tablehead>\n      <tablehead classname=\"text-right\">result</tablehead>\n    </tablerow>\n  </tableheader>\n  <tablebody>\n    <tablerow>\n      <tablecell classname=\"font-medium\">+</tablecell>\n      <tablecell>addition</tablecell>\n      <tablecell>5 + 2</tablecell>\n      <tablecell classname=\"text-right\">7</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">-</tablecell>\n      <tablecell>subtraction</tablecell>\n      <tablecell>5 - 2</tablecell>\n      <tablecell classname=\"text-right\">3</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">*</tablecell>\n      <tablecell>multiplication</tablecell>\n      <tablecell>5 * 2</tablecell>\n      <tablecell classname=\"text-right\">10</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">/</tablecell>\n      <tablecell>division</tablecell>\n      <tablecell>5 / 2</tablecell>\n      <tablecell classname=\"text-right\">2</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">%</tablecell>\n      <tablecell>modulo (truncated)</tablecell>\n      <tablecell>5 % 2</tablecell>\n      <tablecell classname=\"text-right\">1</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">|</tablecell>\n      <tablecell>bitwise or (integers)</tablecell>\n      <tablecell>6 | 3</tablecell>\n      <tablecell classname=\"text-right\">7</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">~</tablecell>\n      <tablecell>bitwise xor (integers)</tablecell>\n      <tablecell>6 ~ 3</tablecell>\n      <tablecell classname=\"text-right\">5</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">&</tablecell>\n      <tablecell>bitwise and (integers)</tablecell>\n      <tablecell>6 & 3</tablecell>\n      <tablecell classname=\"text-right\">2</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">\n        <code>&~</code>\n      </tablecell>\n      <tablecell>bitwise and-not (integers)</tablecell>\n      <tablecell>6 &~ 3</tablecell>\n      <tablecell classname=\"text-right\">4</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">&lt;&lt;</tablecell>\n      <tablecell>left shift (integer &lt;&lt; non-negative integer)</tablecell>\n      <tablecell>3 &lt;&lt; 2</tablecell>\n      <tablecell classname=\"text-right\">12</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">&gt;&gt;</tablecell>\n      <tablecell>right shift (integer &gt;&gt; non-negative integer)</tablecell>\n      <tablecell>12 &gt;&gt; 2</tablecell>\n      <tablecell classname=\"text-right\">3</tablecell>\n    </tablerow>\n  </tablebody>\n</table> <br /> ## comparison operators comparison operators evaluate the relationship between two operands and return a *** result (true or false). <table>\n  <tableheader>\n    <tablerow>\n      <tablehead classname=\"w-[100px]\">operator</tablehead>\n      <tablehead>meaning</tablehead>\n      <tablehead>example</tablehead>\n      <tablehead classname=\"text-right\">result</tablehead>\n    </tablerow>\n  </tableheader>\n  <tablebody>\n    <tablerow>\n      <tablecell classname=\"font-medium\">==</tablecell>\n      <tablecell>equal to</tablecell>\n      <tablecell>5 == 5</tablecell>\n      <tablecell classname=\"text-right\">true</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">!=</tablecell>\n      <tablecell>not equal to</tablecell>\n      <tablecell>5 != 3</tablecell>\n      <tablecell classname=\"text-right\">true</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">&lt;</tablecell>\n      <tablecell>less than</tablecell>\n      <tablecell>3 &lt; 5</tablecell>\n      <tablecell classname=\"text-right\">true</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">&gt;</tablecell>\n      <tablecell>greater than</tablecell>\n      <tablecell>7 &gt; 2</tablecell>\n      <tablecell classname=\"text-right\">true</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">&lt;=</tablecell>\n      <tablecell>less than or equal to</tablecell>\n      <tablecell>3 &lt;= 3</tablecell>\n      <tablecell classname=\"text-right\">true</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">&gt;=</tablecell>\n      <tablecell>greater than or equal to</tablecell>\n      <tablecell>5 &gt;= 2</tablecell>\n      <tablecell classname=\"text-right\">true</tablecell>\n    </tablerow>\n  </tablebody>\n</table> <br /> ## logical operators logical operators are used to combine or invert boolean values. they always operate on true and false values and return a boolean result. <table>\n  <tableheader>\n    <tablerow>\n      <tablehead classname=\"w-[100px]\">operator</tablehead>\n      <tablehead>meaning</tablehead>\n      <tablehead>example</tablehead>\n      <tablehead classname=\"text-right\">result</tablehead>\n    </tablerow>\n  </tableheader>\n  <tablebody>\n    <tablerow>\n      <tablecell classname=\"font-medium\">&amp;&amp;</tablecell>\n      <tablecell>logical and</tablecell>\n      <tablecell>true &amp;&amp; false</tablecell>\n      <tablecell classname=\"text-right\">false</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">||</tablecell>\n      <tablecell>logical or</tablecell>\n      <tablecell>true || false</tablecell>\n      <tablecell classname=\"text-right\">true</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">!</tablecell>\n      <tablecell>logical not</tablecell>\n      <tablecell>!true</tablecell>\n      <tablecell classname=\"text-right\">false</tablecell>\n    </tablerow>\n  </tablebody>\n</table> <br /> ## assignment operators assignment operators are used to assign values to variables.\nthe simplest form is **=**, but there are also compound assignments that perform an operation and assignment in one step. <table>\n  <tableheader>\n    <tablerow>\n      <tablehead classname=\"w-[100px]\">operator</tablehead>\n      <tablehead>meaning</tablehead>\n      <tablehead>example</tablehead>\n      <tablehead classname=\"text-right\">result</tablehead>\n    </tablerow>\n  </tableheader>\n  <tablebody>\n    <tablerow>\n      <tablecell classname=\"font-medium\">=</tablecell>\n      <tablecell>assignment</tablecell>\n      <tablecell>a = 10</tablecell>\n      <tablecell classname=\"text-right\">a = 10</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">+=</tablecell>\n      <tablecell>add and assign</tablecell>\n      <tablecell>a += 5</tablecell>\n      <tablecell classname=\"text-right\">a = a + 5</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">-=</tablecell>\n      <tablecell>subtract and assign</tablecell>\n      <tablecell>a -= 5</tablecell>\n      <tablecell classname=\"text-right\">a = a - 5</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">*=</tablecell>\n      <tablecell>multiply and assign</tablecell>\n      <tablecell>a *= 5</tablecell>\n      <tablecell classname=\"text-right\">a = a * 5</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">/=</tablecell>\n      <tablecell>divide and assign</tablecell>\n      <tablecell>a /= 5</tablecell>\n      <tablecell classname=\"text-right\">a = a / 5</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">%=</tablecell>\n      <tablecell>modulo and assign</tablecell>\n      <tablecell>a %= 5</tablecell>\n      <tablecell classname=\"text-right\">a = a % 5</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">&=</tablecell>\n      <tablecell>bitwise and and assign</tablecell>\n      <tablecell>a &= 5</tablecell>\n      <tablecell classname=\"text-right\">a = a & 5</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">~=</tablecell>\n      <tablecell>bitwise xor and assign</tablecell>\n      <tablecell>a ~= 5</tablecell>\n      <tablecell classname=\"text-right\">a = a ~ 5</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">{\"&~=\"}</tablecell>\n      <tablecell>bitwise and not and assign</tablecell>\n      <tablecell>{\"a &~= 5\"}</tablecell>\n      <tablecell classname=\"text-right\">a = a &~ 5</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">{\"<<=\"}</tablecell>\n      <tablecell>left shift and assign</tablecell>\n      <tablecell>{\"a <<= 2\"}</tablecell>\n      <tablecell classname=\"text-right\">{\"a = a << 2\"}</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">>>=</tablecell>\n      <tablecell>right shift and assign</tablecell>\n      <tablecell>a >>= 2</tablecell>\n      <tablecell classname=\"text-right\">a = a >> 2</tablecell>\n    </tablerow>\n  </tablebody>\n</table> <br /> ## operator precedence & associativity associativity determines how operators of the same precedence are grouped: left-to-right or right-to-left.\nparentheses () can be used to explicitly control evaluation order. <table>\n  <tableheader>\n    <tablerow>\n      <tablehead>operator / type</tablehead>\n      <tablehead>description</tablehead>\n      <tablehead style={{ textalign: \"right\" }}>\n        precedence / associativity\n      </tablehead>\n    </tablerow>\n  </tableheader>\n  <tablebody>\n    <tablerow>\n      <tablecell>lowest</tablecell>\n      <tablecell>\n        represents the lowest precedence. used internally as a default when no\n        other precedence applies.\n      </tablecell>\n      <tablecell style={{ textalign: \"right\" }}>lowest</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>sizeof</tablecell>\n      <tablecell>returns the size of a type or expression in bytes.</tablecell>\n      <tablecell style={{ textalign: \"right\" }}>high / right-to-left</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>||</tablecell>\n      <tablecell>\n        logical or. returns true if at least one operand is true.\n      </tablecell>\n      <tablecell style={{ textalign: \"right\" }}>low / left-to-right</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>&amp;&amp;</tablecell>\n      <tablecell>\n        logical and. returns true only if both operands are true.\n      </tablecell>\n      <tablecell style={{ textalign: \"right\" }}>low / left-to-right</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>==, !=</tablecell>\n      <tablecell>equality and inequality comparison operators.</tablecell>\n      <tablecell style={{ textalign: \"right\" }}>\n        low-mid / left-to-right\n      </tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>&gt;, &lt;, &gt;=, &lt;=</tablecell>\n      <tablecell>relational operators to compare values.</tablecell>\n      <tablecell style={{ textalign: \"right\" }}>mid / left-to-right</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>+, -</tablecell>\n      <tablecell>addition and subtraction operators.</tablecell>\n      <tablecell style={{ textalign: \"right\" }}>\n        mid-high / left-to-right\n      </tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>*, /, %</tablecell>\n      <tablecell>multiplication, division, and modulo operators.</tablecell>\n      <tablecell style={{ textalign: \"right\" }}>high / left-to-right</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>&amp;, |, ~, &amp;~</tablecell>\n      <tablecell>bitwise and, or, not, and custom combination (~&).</tablecell>\n      <tablecell style={{ textalign: \"right\" }}>high / left-to-right</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>-x, !x</tablecell>\n      <tablecell>unary prefix operators: negation and logical not.</tablecell>\n      <tablecell style={{ textalign: \"right\" }}>high / right-to-left</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>&amp;</tablecell>\n      <tablecell>\n        address-of operator. returns the memory address of its operand.\n      </tablecell>\n      <tablecell style={{ textalign: \"right\" }}>\n        lower than member access / right-to-left\n      </tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>*</tablecell>\n      <tablecell>\n        dereference operator. accesses the value pointed to by a pointer.\n      </tablecell>\n      <tablecell style={{ textalign: \"right\" }}>\n        higher than member access / right-to-left\n      </tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>my_function(x)</tablecell>\n      <tablecell>\n        function call. evaluates arguments and calls the function.\n      </tablecell>\n      <tablecell style={{ textalign: \"right\" }}>\n        very high / left-to-right\n      </tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>array[index]</tablecell>\n      <tablecell>\n        array indexing. access the element at a specific position.\n      </tablecell>\n      <tablecell style={{ textalign: \"right\" }}>\n        very high / left-to-right\n      </tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>type conversion (cast)</tablecell>\n      <tablecell>explicitly converts a value to a different type.</tablecell>\n      <tablecell style={{ textalign: \"right\" }}>high / right-to-left</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>.</tablecell>\n      <tablecell>\n        member access. accesses a field of a struct or object.\n      </tablecell>\n      <tablecell style={{ textalign: \"right\" }}>high / left-to-right</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell>-&gt;</tablecell>\n      <tablecell>\n        pointer member access. dereferences a pointer to access a field of a\n        struct or object.\n      </tablecell>\n      <tablecell style={{ textalign: \"right\" }}>high / left-to-right</tablecell>\n    </tablerow>\n  </tablebody>\n</table> <br /> ## unary operators unary operators operate on a single operand and modify its value by **1**.  \n**prefix** (`++i`, `--i`) updates the variable **before** it‚Äôs used in an expression.  \n**postfix** (`i++`, `i--`) updates the variable **after** it‚Äôs used in an expression. <table> <tableheader>\n  <tablerow>\n    <tablehead classname=\"w-[140px]\">operator</tablehead>\n    <tablehead>meaning</tablehead>\n    <tablehead>example</tablehead>\n    <tablehead classname=\"text-right\">result</tablehead>\n  </tablerow>\n</tableheader> <br /> <tablebody>\n  <tablerow>\n    <tablecell classname=\"font-medium\">i++</tablecell>\n    <tablecell>\n      post-increment: returns current value, then increases by 1\n    </tablecell>\n    <tablecell>i = 5; j = i++</tablecell>\n    <tablecell classname=\"text-right\">i = 6, j = 5</tablecell>\n  </tablerow>\n  <tablerow>\n    <tablecell classname=\"font-medium\">++i</tablecell>\n    <tablecell>\n      pre-increment: increases by 1, then returns the new value\n    </tablecell>\n    <tablecell>i = 5; j = ++i</tablecell>\n    <tablecell classname=\"text-right\">i = 6, j = 6</tablecell>\n  </tablerow>\n  <tablerow>\n    <tablecell classname=\"font-medium\">i--</tablecell>\n    <tablecell>\n      post-decrement: returns current value, then decreases by 1\n    </tablecell>\n    <tablecell>i = 5; j = i--</tablecell>\n    <tablecell classname=\"text-right\">i = 4, j = 5</tablecell>\n  </tablerow>\n  <tablerow>\n    <tablecell classname=\"font-medium\">--i</tablecell>\n    <tablecell>\n      pre-decrement: decreases by 1, then returns the new value\n    </tablecell>\n    <tablecell>i = 5; j = --i</tablecell>\n    <tablecell classname=\"text-right\">i = 4, j = 4</tablecell>\n  </tablerow>\n</tablebody> </table> notes: > - works only on mutable lvalues; using on constants or rvalues should be a compile error.\n> - avoid relying on multiple increments of the same variable within a single expression if your language disallows/diagnoses unspecified order of evaluation. <br /> ## null-coalescing operator the null-coalescing operator (||) is used with pointers to select the first non-null value from a chain of operands.  \nit evaluates operands from left to right and returns the first pointer that is not null.  \nif all operands are null, the result is null. ```cyrus\n#p1: int* = null;\n#p2: int* = &x;\n#p3: int* = &y; #result1 = p1 || p2;        // returns p2\n#result2 = p1 || null;      // returns null\n#result3 = p1 || p2 || p3;  // returns p2 (first non-null)\n```",
    "language": "en",
    "category": "tutorial"
  },
  {
    "id": "en-tutorial-functions",
    "title": "Functions",
    "path": "/en/docs/tutorial/functions",
    "content": "Functions in Cyrus are defined using the fn keyword, followed by the function name, parameters, and return type.",
    "searchable": "functions # functions functions in cyrus are defined using the ` keyword, followed by the function name, parameters, and return type. <br /> ## basic function example here's a simple example of a function that adds two integers: ```cyrus\nfn sum(x: int, y: int) int {\n    return x + y;\n}\n``` <br /> ## recursion ```cyrus\nfn main() {\n    fibonacci(10); // expected value: 55\n} fn fibonacci(n: int) int {\n    if (n == 0) {\n        return 0;\n    }\n    else if (n == 1) {\n        return 1;\n    }\n    else {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}\n``` <br /> # function access specifiers in cyrus, functions can be declared with **access specifiers** that control their visibility and behavior.  \nthese specifiers are placed **before** the `fn` keyword. - **extern** - declares that the function is defined outside the current module (e.g., in a c library). useful for interoperability. ```cyrus\nextern fn printf(format: const char*, ...) int32;\n``` only valid for declarations. - **pub** makes the function visible outside the current module. without `pub`, a function is private by default and can only be used within the same module. ```cyrus\npub fn sum(a: int, b: int) int {\n    return a + b;\n}\n``` - **inline** hints to the compiler that the function body should be expanded inline at call sites (for performance). this is most effective with **small utility functions**. ```cyrus\ninline fn square(x: int) int {\n    return x * x;\n}\n``` - **pub inline** a combination: visible outside the module and a candidate for inlining. ```cyrus\npub inline fn abs(x: int) int {\n    if (x < 0) {\n        return -x;\n    } else {\n        return x;\n    }\n}\n``` - **pub extern** declares an **external function** that is also exported from the current module. this is commonly used when exposing bindings or apis. ```cyrus\npub extern fn sin(x: float64) float64;\n``` <br /> ## variadic arguments cyrus supports two kinds of variadic arguments, allowing functions to accept a variable number of parameters. <br /> ### c-style variadic arguments c-style variadic functions use the `...` notation, just like in c. these are typically used for **interfacing with c libraries** (e.g., `printf`) or when type safety is not a concern. ```cyrus\nextern fn printf(format: const char*, ...) int; fn main() {\n    printf(\"hello %s, number = %d\\n\", \"cyrus\", 42);\n}\n``` - use this style primarily for compatibility with c and low-level apis.  \n- inside the function body, such arguments are accessed with platform-specific varargs handling (similar to c's `va_list`). <br /> ### typed variadic arguments (not implemented yet.) typed variadic functions allow specifying **one type** that repeats for an arbitrary number of arguments. this gives type safety and better compiler optimizations. ```cyrus\nfn sum_all(nums: int...) int {\n    // coming soon.\n} fn main() {\n    #s: int = sum_all(1, 2, 3, 4, 5);\n    printf(\"%d\\n\", s); // output: 15\n}\n```\n<br /> ## function abi name  cyrus allows you to specify a **different abi-level (linker) name** for a function than its cyrus name. this is done using the `as` keyword after the declaration.   ```cyrus\nextern fn printf(fmt: string, ...) int as my_printf; fn main() {\n    my_printf(\"hello, %s!\\n\", \"cyrus\");\n}\n``` - the function is **declared as `printf`** at the abi level, so it links against the real `printf` symbol in the c standard library.\n- inside cyrus, however, the function is referred to as **`my_printf`**.\n- this allows you to avoid naming conflicts or to wrap existing library functions under more descriptive names. <br /> # lambdas lambdas in cyrus are anonymous functions. they look and behave like normal functions, but they don't need a name. you define them inline, assign them to variables, pass them around, or embed them inside structs. unlike closures in some other languages, cyrus lambdas do not capture the surrounding environment. they are pure function objects defined with a clear, fixed signature. <br /> ### function types every lambda has a function type, which describes its parameters and return type.\nfor example: ```cyrus\ntype handlerfn = fn(int, int) void;\n``` <br /> ### defining a lambda the syntax is straightforward: ```cyrus\nfn(x: int, y: int) int {\n    return x + y;\n}\n``` <br /> ### assigning to variables you can store lambdas in variables: ```cyrus\nfn main() {\n    #add = fn(x: int, y: int) int {\n        return x + y;\n    };     printf(\"%d\\n\", add(2, 3)); // prints 5\n}\n``` <br /> ### no environment capture in cyrus, **lambdas are not closures**.\nthat means they cannot capture variables from their surrounding scope. for example: ```cyrus\nfn main() {\n    #base = 10;     #adder = fn(x: int) int {\n        return x + base; // ‚ùå `base` is not accessible here\n    };\n}\n```",
    "language": "en",
    "category": "tutorial"
  },
  {
    "id": "en-tutorial-generic_types",
    "title": "Generic Types",
    "path": "/en/docs/tutorial/generic_types",
    "content": "Coming soon......",
    "searchable": "generic types coming soon...",
    "language": "en",
    "category": "tutorial"
  },
  {
    "id": "en-tutorial-inline_assembly",
    "title": "Inline Assembly",
    "path": "/en/docs/tutorial/inline_assembly",
    "content": "Coming soon......",
    "searchable": "inline assembly coming soon...",
    "language": "en",
    "category": "tutorial"
  },
  {
    "id": "en-tutorial-macros",
    "title": "Macros",
    "path": "/en/docs/tutorial/macros",
    "content": "Coming soon......",
    "searchable": "macros coming soon...",
    "language": "en",
    "category": "tutorial"
  },
  {
    "id": "en-tutorial-memory_management",
    "title": "Memory Management",
    "path": "/en/docs/tutorial/memory_management",
    "content": "Coming soon......",
    "searchable": "memory management coming soon...",
    "language": "en",
    "category": "tutorial"
  },
  {
    "id": "en-tutorial-modules",
    "title": "Modules",
    "path": "/en/docs/tutorial/modules",
    "content": "Cyrus features a powerful module system with incremental compilation and a strong module cache. Modules allow code organization, reusability, and proper scoping.",
    "searchable": "modules # modules cyrus features a * module system** with **incremental compilation** and a **strong module cache**. modules allow code organization, reusability, and proper scoping. <br /> ## module files in cyrus, **files are considered modules**. module files must: - use **snake_case** names\n- have the `.cyr` extension example: `user_utils.cyr` defines a module named `user_utils`. inside user_utils.cyr: ```cyrus\npub fn greet(name: str) {\n  printf(\"hello, %s!\\n\", name);\n}\n``` <br /> ## importing modules to use a module in another file, you import it. ```cyrus\nimport user_utils; fn main() {\n  user_utils::greet(\"cyrus\");\n}\n``` notes: - the entry file (the one you compile as main) cannot import other modules; it is considered the root.\n- only publicly exported symbols (declared with pub) are visible outside their module. <br /> ## importing single symbols you can import only a single symbol instead of the whole module: ```cyrus\nimport user_utils{greet}; fn main() {\n  greet(\"alice\"); // no need for module path prefix\n}\n``` <br /> ## importing multiple modules for convenience, cyrus supports grouped imports: ```cyrus\nimport (\n  math_ops,\n  user_utils{greet}\n); fn main() {\n  #sum = math_ops::add(3, 5);\n  greet(\"bob\");\n}\n``` <br /> ## renaming imported symbols renaming avoids conflicts or makes names clearer.    - renaming a symbol ```cyrus\nimport user_utils{greet as greet_renamed}; fn main() {\n  greet_renamed(\"charlie\");\n}\n``` - renaming a module ```cyrus\nimport math_ops as my_math; fn main() {\n  #result = my_math::mul(4, 6);\n}\n```",
    "language": "en",
    "category": "tutorial"
  },
  {
    "id": "en-tutorial-project_configuration",
    "title": "Project Configuration",
    "path": "/en/docs/tutorial/project_configuration",
    "content": "Coming soon......",
    "searchable": "project configuration coming soon...",
    "language": "en",
    "category": "tutorial"
  },
  {
    "id": "en-tutorial-reflection",
    "title": "Reflection",
    "path": "/en/docs/tutorial/reflection",
    "content": "Coming soon......",
    "searchable": "reflection coming soon...",
    "language": "en",
    "category": "tutorial"
  },
  {
    "id": "en-tutorial-structs",
    "title": "Structs",
    "path": "/en/docs/tutorial/structs",
    "content": "Structs in Cyrus are user-defined composite types that allow grouping related data together.  They are similar to struct in C/C++ but follow Cyrus' type system rules.",
    "searchable": "structs # structs  structs in cyrus are *-defined composite types** that allow grouping related data together.  they are similar to `struct` in c/c++ but follow cyrus' type system rules. <br /> ## defining a struct use the `struct` keyword, followed by the name and fields: ```cyrus\nstruct user {\n    name: char*;\n    age: uint;\n    king: bool;\n}\n``` <br /> ## initializing a struct structs can be initialized using **struct literals**: ```cyrus\n#user = user {\n    name: \"cyrus\",\n    age: 2500,\n    king: true\n};\n``` <br /> ## accessing struct fields you can access struct fields using the **dot (`.`) operator**: ```cyrus\nuser.name; // output: cyrus\nuser.age;  // output: 2500\nuser.king; // output: true\n``` <br /> ## methods  structs can define functions inside their body, called **methods**. ```cyrus\npub struct logger {\n    pub group: char*;     pub fn new(group: char*) logger { \n        logger.logger_initialized();\n        return logger { group: group };\n    }     inline fn logger_initialized() {\n        libc::fprintf(libc::stdout, \"logger init.\\n\");\n    }     pub fn logf(&self, format: char*) {\n        libc::printf(\"[info][%s] %s\\n\", self->group, format);\n    }     pub inline fn errorf(self, format: char*) {\n        libc::fprintf(libc::stderr, \"[error][%s] %s\\n\", self->group, format);\n    }\n}\n``` <br /> ## static methods static methods do not require a struct instance. called on the struct type itself. it often used as constructor or helper functions. ```cyrus\npub fn new(group: char*) logger {\n    return logger { group: group };\n}\n``` <br /> ## instance methods instance methods operate on a struct instance and can access its fields. ```cyrus\npub fn logf(&self, format: char*) {\n    libc::printf(\"[info][%s] %s\\n\", self->group, format);\n} pub fn errorf(self, format: char*) {\n    libc::fprintf(libc::stderr, \"[error][%s] %s\\n\", self->group, format);\n}\n``` <br /> ## reference vs copy cyrus allows controlling how instance methods receive the struct: - `&self` ‚Üí passes a **reference** to the instance (does not copy)  \n- `self` ‚Üí passes a **copy** of the instance (moves it) ```cyrus\npub fn logf(&self, format: char*) { ... } // reference\npub fn errorf(self, format: char*) { ... } // copy\n``` note: attempting to get a reference (&self) from a const-lvalue is not allowed. the compiler will issue an error to prevent modifying or referencing immutable data. <br /> ## fat arrows in cyrus, you can have pointers to structs. when accessing fields or calling methods through a pointer, you can use **fat pointers** (fat arrows) which **automatically dereference** the pointer. ```cyrus\n#user = user { name: \"cyrus\", age: 2500 }; \n#ptr = &user; ptr->name; // output: cyrus\nptr->age; // output: 2500\n``` note: using **ptr->name** or **ptr->age** is equivalent to **{\"(*ptr).name\"}** and **{\"(*ptr).age\"}**. <br /> ## local structs in cyrus, structs can also be declared **locally inside functions**. this is useful when the type is only relevant to that function and should not pollute the global scope. ```cyrus\nfn main() {\n    struct user {\n        name: char*;\n        age: uint;\n    }     #user = user { name: \"cyrus\", age: 2500 }; \n    libc::printf(\"%s is %d years old.\\n\", user.name, user.age);\n}\n``` <br /> ## unnamed structs unnamed structs are struct values declared inline without defining a named type. they are useful for quick, one-off configurations or temporary data holders. ```cyrus\nfn main() {\n    #state = struct {\n        name = \"cyrus\",\n        counter = 0,\n    };     config.name; \n    state.counter += 1;\n}\n``` field types are inferred automatically. <br /> ## typed unnamed struct you can also specify field types explicitly: ```cyrus\n#state = struct {\n    name: char* = \"cyrus\",\n    counter: int = 0,\n};\n``` note: unnamed structs cannot define methods. <br /> ## global unnamed structs unnamed structs are not limited to local scope. they can also be declared globally and accessed across functions (if marked public). ```cyrus\npub config = const struct {\n    host = \"127.0.0.1\",\n    port = 8080\n}; fn main() {\n    printf(\"host: %s\\n\", config.host);\n    printf(\"port: %d\\n\", config.port);\n}\n```",
    "language": "en",
    "category": "tutorial"
  },
  {
    "id": "en-tutorial-tutorial",
    "title": "Tutorial",
    "path": "/en/docs/tutorial/tutorial",
    "content": "...",
    "searchable": "tutorial ",
    "language": "en",
    "category": "tutorial"
  },
  {
    "id": "en-tutorial-types",
    "title": "Types",
    "path": "/en/docs/tutorial/types",
    "content": "Cyrus features a strong and expressive type system. The compiler performs implicit type conversions when it is safe, and requires explicit casts when conversions could be unsafe or lossy.",
    "searchable": "types # type system cyrus features a * and expressive type system**. the compiler performs **implicit type conversions** when it is safe, and requires **explicit casts** when conversions could be unsafe or lossy. <br /> ## safe implicit casting if a type can be safely converted to another type without losing information, cyrus will perform the conversion automatically.   ```cyrus\n#a: int32 = 42;\n#b: int64 = a; // implicit cast from int32 to int64\n``` - `int32` (32-bit signed integer) can always fit into `int64` (64-bit signed integer).  \n- the compiler handles this **implicitly**, so no special syntax is required.  \n- safe casts also apply to numeric literals, e.g., `#x: float64 = 10.0` is allowed. <br /> ## unsafe / explicit casting if a conversion **could be unsafe**, the compiler requires an **explicit cast** using the `cast` keyword. ```cyrus\n#u: uint32 = 10;\n#i: int64 = cast(int64, u); // explicit unsafe cast from uint32 to int64\n``` <br /> # basic types cyrus provides a set of built-in types for numbers, characters, booleans, and special-purpose values. these are the fundamental building blocks of your programs. <table>\n  <tableheader>\n    <tablerow>\n      <tablehead classname=\"w-[160px]\">type</tablehead>\n      <tablehead>category</tablehead>\n      <tablehead>bit width</tablehead>\n      <tablehead classname=\"text-right\">signedness</tablehead>\n    </tablerow>\n  </tableheader>\n  <tablebody>\n    <tablerow>\n      <tablecell classname=\"font-medium\">int</tablecell>\n      <tablecell>signed integer (default)</tablecell>\n      <tablecell>target-dependent (usually 32 or 64)</tablecell>\n      <tablecell classname=\"text-right\">signed</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">int8</tablecell>\n      <tablecell>signed integer</tablecell>\n      <tablecell>8</tablecell>\n      <tablecell classname=\"text-right\">signed</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">int16</tablecell>\n      <tablecell>signed integer</tablecell>\n      <tablecell>16</tablecell>\n      <tablecell classname=\"text-right\">signed</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">int32</tablecell>\n      <tablecell>signed integer</tablecell>\n      <tablecell>32</tablecell>\n      <tablecell classname=\"text-right\">signed</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">int64</tablecell>\n      <tablecell>signed integer</tablecell>\n      <tablecell>64</tablecell>\n      <tablecell classname=\"text-right\">signed</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">int128</tablecell>\n      <tablecell>signed integer</tablecell>\n      <tablecell>128</tablecell>\n      <tablecell classname=\"text-right\">signed</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">uint</tablecell>\n      <tablecell>unsigned integer (default)</tablecell>\n      <tablecell>target-dependent (usually 32 or 64)</tablecell>\n      <tablecell classname=\"text-right\">unsigned</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">uint8</tablecell>\n      <tablecell>unsigned integer</tablecell>\n      <tablecell>8</tablecell>\n      <tablecell classname=\"text-right\">unsigned</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">uint16</tablecell>\n      <tablecell>unsigned integer</tablecell>\n      <tablecell>16</tablecell>\n      <tablecell classname=\"text-right\">unsigned</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">uint32</tablecell>\n      <tablecell>unsigned integer</tablecell>\n      <tablecell>32</tablecell>\n      <tablecell classname=\"text-right\">unsigned</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">uint64</tablecell>\n      <tablecell>unsigned integer</tablecell>\n      <tablecell>64</tablecell>\n      <tablecell classname=\"text-right\">unsigned</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">uint128</tablecell>\n      <tablecell>unsigned integer</tablecell>\n      <tablecell>128</tablecell>\n      <tablecell classname=\"text-right\">unsigned</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">intptr</tablecell>\n      <tablecell>pointer-sized integer</tablecell>\n      <tablecell>pointer width (32 or 64)</tablecell>\n      <tablecell classname=\"text-right\">signed</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">uintptr</tablecell>\n      <tablecell>pointer-sized integer</tablecell>\n      <tablecell>pointer width (32 or 64)</tablecell>\n      <tablecell classname=\"text-right\">unsigned</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">size_t</tablecell>\n      <tablecell>size / index type</tablecell>\n      <tablecell>pointer width (32 or 64)</tablecell>\n      <tablecell classname=\"text-right\">unsigned</tablecell>\n    </tablerow>\n  </tablebody>\n</table> <br /> ### floating-point types <table>\n  <tableheader>\n    <tablerow>\n      <tablehead classname=\"w-[150px]\">type</tablehead>\n      <tablehead>description</tablehead>\n      <tablehead classname=\"text-right\">precision</tablehead>\n    </tablerow>\n  </tableheader>\n  <tablebody>\n    <tablerow>\n      <tablecell classname=\"font-medium\">float16</tablecell>\n      <tablecell>16-bit floating-point number (half precision)</tablecell>\n      <tablecell classname=\"text-right\">~3 decimal digits</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">float32</tablecell>\n      <tablecell>32-bit floating-point number (single precision)</tablecell>\n      <tablecell classname=\"text-right\">~7 decimal digits</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">float64</tablecell>\n      <tablecell>64-bit floating-point number (double precision)</tablecell>\n      <tablecell classname=\"text-right\">~15‚Äì16 decimal digits</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">float128</tablecell>\n      <tablecell>128-bit floating-point number (quadruple precision)</tablecell>\n      <tablecell classname=\"text-right\">~34 decimal digits</tablecell>\n    </tablerow>\n  </tablebody>\n</table> <br /> ### character and boolean types <table>\n  <tableheader>\n    <tablerow>\n      <tablehead classname=\"w-[150px]\">type</tablehead>\n      <tablehead>description</tablehead>\n      <tablehead classname=\"text-right\">notes</tablehead>\n    </tablerow>\n  </tableheader>\n  <tablebody>\n    <tablerow>\n      <tablecell classname=\"font-medium\">char</tablecell>\n      <tablecell>a single character unit (one code unit; multi-byte unicode not allowed in `'...'`).</tablecell>\n      <tablecell classname=\"text-right\">represents ascii/byte chars only</tablecell>\n    </tablerow>\n    <tablerow>\n      <tablecell classname=\"font-medium\">bool</tablecell>\n      <tablecell>boolean values, either <code>true</code> or <code>false</code>.</tablecell>\n      <tablecell classname=\"text-right\">1-bit storage (typically padded to 8 bits)</tablecell>\n    </tablerow>\n  </tablebody>\n</table> <br /> ### special types <table>\n  <tableheader>\n    <tablerow>\n      <tablehead classname=\"w-[150px]\">type</tablehead>\n      <tablehead>description</tablehead>\n      <tablehead classname=\"text-right\">notes</tablehead>\n    </tablerow>\n  </tableheader>\n  <tablebody>\n     <tablerow>\n      <tablecell classname=\"font-medium\">void</tablecell>\n      <tablecell>represents no value, commonly used for functions that do not return anything.</tablecell>\n      <tablecell classname=\"text-right\">return type only</tablecell>\n    </tablerow>\n  </tablebody>\n</table>",
    "language": "en",
    "category": "tutorial"
  },
  {
    "id": "en-tutorial-unions",
    "title": "Unions",
    "path": "/en/docs/tutorial/unions",
    "content": "A Union in Cyrus is a composite data type similar to C-style unions.",
    "searchable": "unions # unions a union in cyrus is a composite data type similar to c-style unions. \nit allows multiple fields to share the same memory location, so only one of its fields can hold a valid value at any given time. unlike structs, writing to one field will overwrite the memory for all others. <br /> <warningalert title=\"unions are not memory-safe\">\n  unions in cyrus are not memory-safe. reading a field that was not most recently \n  written is undefined behavior, just like in c. use unions only when you explicitly \n  need memory-efficient, low-level data representations.\n</warningalert> <infoalert title=\"safe alternative\">\n  if you want a memory-safe way to store different types of values, use an enum, \n  which enforces at compile time which variant is active.\n</infoalert> <br /> ## defining a union ``\nunion dataunion {\n    a: int;\n    b: float64;\n} fn main() {\n    #un = dataunion;\n    un.b = 3.14;\n}\n``` <br /> ## using a union you can create a union instance and assign fields directly: ```cyrus\nfn main() {\n    #un = dataunion;\n    un.a = 42;       // set the integer field\n    un.b = 3.14;     // overwrites the same memory with a float\n}\n``` after un.b = 3.14, the value of un.a is no longer valid. <br /> ## union initialization unions can be initialized using a union initializer, specifying which field to set at creation: ```cyrus\n#un: dataunion = dataunion { a: 10 };\n``` rules: - only one field should be initialized.\n- the union's memory will be set according to that field. <br /> ## practical use cases unions are low-level tools, mainly used in systems programming: - type punning: reinterpret the same memory as different types.\n- interfacing with c libraries: many c apis expose unions in their structs.\n- memory efficiency: when you know only one of several large fields will be used at once. example: interpreting the same 32-bit data as either an integer or raw bytes. ```cyrus\nimport std::libc{printf}; union intbytes {\n    value: int;\n    bytes: uint8[4];\n} fn main() {\n    #data = intbytes { value: 0x12345678 };     printf(\"%x %x %x %x\\n\", data.bytes[0], data.bytes[1], data.bytes[2], data.bytes[3]);\n}\n``` output (on little-endian systems): ```text\n78 56 34 12\n```",
    "language": "en",
    "category": "tutorial"
  },
  {
    "id": "en-tutorial-variables",
    "title": "Variables",
    "path": "/en/docs/tutorial/variables",
    "content": "Variables in Cyrus are declared using the # symbol:",
    "searchable": "variables # variables variables in cyrus are declared using the # symbol: ``\n#name: optionaltype = value;\n``` - **#name** - the variable name, always prefixed with #\n- **optionaltype** - (optional) the type of the variable; if omitted, the compiler infers it\n- **value** - the initial value assigned to the variable example ```cyrus\n#count: int = 42;                   // explicit type annotation\n#message: char* = \"hello, cyrus!\";  // explicit type annotation\n#flag = true;                       // type inferred as bool\n``` <br /> ## why sharp (#)? the # prefix is unique to cyrus. it makes variable declarations easy to spot and improves editor syntax highlighting.   \nusing # instead of keywords like var or let keeps code shorter and visually distinct.   \ntype inference works automatically when the type is omitted.     <br /> ## zero initialization variables that are declared without an initial value are automatically zero-initialized: ```cyrus\n#x: int;\n#y: float64;\n#ptr: int*; printf(\"%d\\n\", x);   // prints 0\nprintf(\"%f\\n\", y);   // prints 0.0\nprintf(\"%p\\n\", ptr); // prints null / 0\n``` <br /> ## variable mutability in cyrus, variables are mutable by default. you can assign new values to them after their initial declaration: ```cyrus\n#counter: int = 0;\n#counter = 10; // allowed\n``` to declare a **read-only variable**, use the const keyword before the type: ```cyrus\n#pi: const float64 = 3.14159;\n``` - const type variables cannot be reassigned after initialization.\n- must be initialized at the time of declaration; leaving it uninitialized is not allowed. ```cyrus\n#pi: const float64; // ‚ùå const variable must be initialized\n#pi = 3.14159;      // ‚ùå cannot assign to const variable\n```",
    "language": "en",
    "category": "tutorial"
  },
  {
    "id": "fa-getting-started-build-from-source",
    "title": "ÿ≥ÿßÿÆÿ™ ÿßÿ≤ ŸÖŸÜÿ®ÿπ",
    "path": "/fa/docs/getting-started/build-from-source",
    "content": "ÿß⁄Øÿ± ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿ±ÿß ÿßÿ≤ ⁄©ÿØ ŸÖŸÜÿ®ÿπ ÿ®ÿ≥ÿßÿ≤€åÿØ:",
    "searchable": "ÿ≥ÿßÿÆÿ™ ÿßÿ≤ ŸÖŸÜÿ®ÿπ # ÿ≥ÿßÿÆÿ™ ÿßÿ≤ ŸÖŸÜÿ®ÿπ ÿß⁄Øÿ± ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿ±ÿß ÿßÿ≤ ⁄©ÿØ ŸÖŸÜÿ®ÿπ ÿ®ÿ≥ÿßÿ≤€åÿØ: ## Ÿæ€åÿ¥‚ÄåŸÜ€åÿßÿ≤Ÿáÿß - rust 1.70+\n- cargo\n- git ## ŸÖÿ±ÿßÿ≠ŸÑ ÿ≥ÿßÿÆÿ™ ``\ngit clone https://github.com/cyrus-lang/cyrus.git\ncd cyrus\ncargo build --release\n``` ## ŸÜÿµÿ® ```bash\ncargo install --path .\n```",
    "language": "fa",
    "category": "getting-started"
  },
  {
    "id": "fa-getting-started-design-goals",
    "title": "ÿßŸáÿØÿßŸÅ ÿ∑ÿ±ÿßÿ≠€å",
    "path": "/fa/docs/getting-started/design-goals",
    "content": "ÿ≥ÿß€åÿ±Ÿàÿ≥ €å⁄© ÿ≤ÿ®ÿßŸÜ ÿ®ÿ±ŸÜÿßŸÖŸá‚ÄåŸÜŸà€åÿ≥€å ÿ≥ÿ∑ÿ≠ ŸÖ€åÿßŸÜ€å Ÿà Imperative ÿßÿ≥ÿ™ ⁄©Ÿá ÿ®ÿ±ÿß€å ÿ™Ÿàÿ≥ÿπŸá‚ÄåÿØŸáŸÜÿØ⁄ØÿßŸÜ€å ÿ∑ÿ±ÿßÿ≠€å ÿ¥ÿØŸá ⁄©Ÿá ÿ®Ÿá ÿØŸÜÿ®ÿßŸÑ ŸÇÿØÿ±ÿ™ ŸÖÿØÿ±ŸÜ Ÿáÿ≥ÿ™ŸÜÿØÿå ÿßŸÖÿß ÿ™ŸÖÿß€åŸÑ€å ÿ®Ÿá Ÿæ€å⁄Ü€åÿØ⁄Ø€å‚ÄåŸáÿß€å ŸÖÿØÿ±ŸÜ ŸÜÿØÿßÿ±ŸÜÿØ.",
    "searchable": "ÿßŸáÿØÿßŸÅ ÿ∑ÿ±ÿßÿ≠€å # ÿ≤ÿ®ÿßŸÜ ÿ®ÿ±ŸÜÿßŸÖŸá‚ÄåŸÜŸà€åÿ≥€å ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿ≥ÿß€åÿ±Ÿàÿ≥ €å⁄© ÿ≤ÿ®ÿßŸÜ ÿ®ÿ±ŸÜÿßŸÖŸá‚ÄåŸÜŸà€åÿ≥€å ÿ≥ÿ∑ÿ≠ ŸÖ€åÿßŸÜ€å Ÿà imperative ÿßÿ≥ÿ™ ⁄©Ÿá ÿ®ÿ±ÿß€å ÿ™Ÿàÿ≥ÿπŸá‚ÄåÿØŸáŸÜÿØ⁄ØÿßŸÜ€å ÿ∑ÿ±ÿßÿ≠€å ÿ¥ÿØŸá ⁄©Ÿá ÿ®Ÿá ÿØŸÜÿ®ÿßŸÑ ŸÇÿØÿ±ÿ™ ŸÖÿØÿ±ŸÜ Ÿáÿ≥ÿ™ŸÜÿØÿå ÿßŸÖÿß ÿ™ŸÖÿß€åŸÑ€å ÿ®Ÿá Ÿæ€å⁄Ü€åÿØ⁄Ø€å‚ÄåŸáÿß€å ŸÖÿØÿ±ŸÜ ŸÜÿØÿßÿ±ŸÜÿØ. ÿß€åŸÜ ÿ≤ÿ®ÿßŸÜ ÿ®ÿß ÿ™ŸÖÿ±⁄©ÿ≤ ÿ®ÿ± ÿπŸÖŸÑ⁄©ÿ±ÿØ ÿ®ÿßŸÑÿß Ÿà Ÿàÿ∂Ÿàÿ≠ ÿ∑ÿ±ÿßÿ≠€å ÿ¥ÿØŸá ÿßÿ≥ÿ™. ÿØÿßÿ±ÿß€å €å⁄© ŸÖÿØŸÑ ÿ≠ÿßŸÅÿ∏Ÿá ÿ≥ÿ®⁄©ÿå ÿ®ÿØŸàŸÜ Ÿàÿßÿ®ÿ≥ÿ™⁄Ø€å ÿ®Ÿá ÿ±ÿßŸÜÿ™ÿß€åŸÖÿå Ÿà ŸÜ⁄Øÿßÿ±ÿ¥€å ÿ≥ÿßÿØŸá Ÿà ÿßÿ®ÿØÿßÿπ€å ÿßÿ≥ÿ™. ÿß⁄Øÿ± ÿ®ÿß ÿ≤ÿ®ÿßŸÜ‚ÄåŸáÿß€å€å ŸÖÿßŸÜŸÜÿØ c €åÿß go ÿ¢ÿ¥ŸÜÿß€å€å ÿØÿßÿ¥ÿ™Ÿá ÿ®ÿßÿ¥€åÿØÿå ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿ®ÿ±ÿß€åÿ™ÿßŸÜ ŸÖÿ≠€åÿ∑€å ÿ¢ÿ¥ŸÜÿß Ÿà ÿ≠ÿ™€å ŸÑÿ∞ÿ™‚Äåÿ®ÿÆÿ¥‚Äåÿ™ÿ± ÿÆŸàÿßŸáÿØ ÿ®ŸàÿØ. --- ## ‚ú® ŸÅŸÑÿ≥ŸÅŸá‚Äå€å ÿßÿµŸÑ€å ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿßÿ≤ ÿØŸÑ ŸÜÿßÿ±ÿ∂ÿß€åÿ™€å ÿßÿ≤ Ÿæ€å⁄Ü€åÿØ⁄Ø€å ÿ®€å‚ÄåŸÖŸàÿ±ÿØ ÿ≤ÿ®ÿßŸÜ‚ÄåŸáÿß€å ÿ®ÿ±ŸÜÿßŸÖŸá‚ÄåŸÜŸà€åÿ≥€å ŸÖÿØÿ±ŸÜ ÿ≤ÿßÿØŸá ÿ¥ÿØ. ⁄Øÿ±⁄ÜŸá ÿ≤ÿ®ÿßŸÜ‚ÄåŸáÿß€å€å ŸÖÿßŸÜŸÜÿØ rust Ÿà go ŸÇÿßÿ®ŸÑ€åÿ™‚ÄåŸáÿß€å ÿ≤€åÿßÿØ€å ÿØÿßÿ±ŸÜÿØÿå ÿßŸÖÿß ŸáŸÖÿ±ÿßŸá ÿ¢ŸÜ‚ÄåŸáÿß ŸÖŸÜÿ≠ŸÜ€å €åÿßÿØ⁄Ø€åÿ±€åÿå Ÿæ€å⁄Ü€åÿØ⁄Ø€å ÿ±ÿßŸÜÿ™ÿß€åŸÖÿå €åÿß ÿßŸÜÿ™ÿ≤ÿßÿπÿßÿ™€å ÿßÿ±ÿßÿ¶Ÿá ŸÖ€å‚Äåÿ¥ŸàÿØ ⁄©Ÿá ÿ®ÿ≥€åÿßÿ±€å ÿßÿ≤ ÿ®ÿ±ŸÜÿßŸÖŸá‚ÄåŸÜŸà€åÿ≥ÿßŸÜ ÿ≥€åÿ≥ÿ™ŸÖ ŸàÿßŸÇÿπÿßŸã ŸÜ€åÿßÿ≤€å ÿ®Ÿá ÿ¢ŸÜ‚ÄåŸáÿß ŸÜÿØÿßÿ±ŸÜÿØ. ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿ®ÿ± Ÿæÿß€åŸá‚Äå€å ÿß€åŸÜ ŸÅÿ±ÿ∂ ÿ®ŸÜÿß ÿ¥ÿØŸá ⁄©Ÿá **ÿ≥ÿßÿØ⁄Ø€åÿå ÿµÿ±ÿßÿ≠ÿ™ÿå Ÿà ÿ≤€åÿ®ÿß€å€å** ŸÖ€å‚Äåÿ™ŸàÿßŸÜŸÜÿØ ÿØÿ± ⁄©ŸÜÿßÿ± ŸáŸÖ Ÿàÿ¨ŸàÿØ ÿØÿßÿ¥ÿ™Ÿá ÿ®ÿßÿ¥ŸÜÿØÿõ ÿ®ÿØŸàŸÜ ÿ¢ŸÜ‚Äå⁄©Ÿá ⁄Ü€åÿ≤€å ÿßÿ≤ ÿπŸÖŸÑ⁄©ÿ±ÿØ ⁄©ÿßÿ≥ÿ™Ÿá ÿ¥ŸàÿØ. --- ## üöÄ Ÿà€å⁄ò⁄Ø€å‚ÄåŸáÿß ### üß† ÿ≥ÿßÿØ⁄Ø€å ŸÖÿ®ÿ™ŸÜ€å ÿ®ÿ± ÿ≥€åŸÜÿ™⁄©ÿ≥ - ÿßÿ≤ Ÿæÿß€åŸá ÿ®ÿß ŸáÿØŸÅ **ÿ≠ÿØÿß⁄©ÿ´ÿ± ÿÆŸàÿßŸÜÿß€å€å Ÿà ÿ≠ÿØÿßŸÇŸÑ ÿ®ÿßÿ± ÿ∞ŸáŸÜ€å** ÿ∑ÿ±ÿßÿ≠€å ÿ¥ÿØŸá ÿßÿ≥ÿ™.\n- ⁄©ŸÑŸàŸÜ€å ÿßÿ≤ c ŸÜ€åÿ≥ÿ™ÿå ÿßŸÖÿß ÿ®ÿ±ÿß€å ÿ∞ŸáŸÜ‚ÄåŸáÿß€å€å ⁄©Ÿá ÿ®Ÿá ÿ≥ÿ®⁄© c ŸÅ⁄©ÿ± ŸÖ€å‚Äå⁄©ŸÜŸÜÿØ ÿ®ÿ≥€åÿßÿ± ÿ¢ÿ¥ŸÜÿß ÿÆŸàÿßŸáÿØ ÿ®ŸàÿØ.\n- ÿ®ÿØŸàŸÜ ÿ¨ÿßÿØŸà€å ŸæŸÜŸáÿßŸÜÿå ÿ®ÿØŸàŸÜ ÿ™ÿ®ÿØ€åŸÑ‚ÄåŸáÿß€å ŸÜÿßŸÖÿ±ÿ¶€åÿå Ÿà ÿ®ÿØŸàŸÜ ŸÇŸàÿßÿπÿØ Ÿæ€å⁄Ü€åÿØŸá Ÿà ÿ∫€åÿ±ŸÇÿßÿ®ŸÑ ÿØÿ±⁄©. ### ‚öôÔ∏è ŸÖÿØ€åÿ±€åÿ™ ÿ≠ÿßŸÅÿ∏Ÿá - **ÿ®ÿØŸàŸÜ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ ⁄Øÿßÿ±ÿ®ÿ¨ ⁄©ÿßŸÑ⁄©ÿ™Ÿàÿ± (gc)**.\n- ÿ®Ÿáÿ±Ÿá‚Äå⁄Ø€åÿ±€å ÿßÿ≤ **ÿßÿ®ÿ¨⁄©ÿ™‚ÄåŸáÿß€å ÿßŸÑŸà⁄©€åÿ™ÿ± ÿ≥ŸÅÿßÿ±ÿ¥€å** Ÿà **ŸÖÿ≠ÿØŸàÿØŸá‚ÄåŸáÿß€å ÿ∑ŸàŸÑ ÿπŸÖÿ± (lifetime zones)** ÿ®ÿ±ÿß€å ⁄Øÿ±ŸàŸá‚Äåÿ®ŸÜÿØ€å Ÿà ÿ¢ÿ≤ÿßÿØÿ≥ÿßÿ≤€å ÿ≠ÿßŸÅÿ∏Ÿá.\n- ⁄©ŸÜÿ™ÿ±ŸÑ ⁄©ÿßŸÖŸÑÿßŸã Ÿæ€åÿ¥‚Äåÿ®€åŸÜ€å‚ÄåŸæÿ∞€åÿ± Ÿà ÿ®ÿØŸàŸÜ ŸÖÿØŸÑ‚ÄåŸáÿß€å Ÿæ€å⁄Ü€åÿØŸá‚Äå€å ŸÖÿßŸÑ⁄©€åÿ™ ŸÖÿßŸÜŸÜÿØ rust.\n- ÿ∑ÿ±ÿßÿ≠€å‚Äåÿ¥ÿØŸá ÿ®ÿß ŸáÿØŸÅ **ÿ®ÿ±ÿ±ÿ≥€å ÿß€åŸÖŸÜ€å ÿØÿ± ÿ≤ŸÖÿßŸÜ ⁄©ÿßŸÖŸæÿß€åŸÑ** Ÿà ÿØÿÆÿßŸÑÿ™ ÿ≠ÿØÿßŸÇŸÑ€å ÿØÿ± ÿ≤ŸÖÿßŸÜ ÿßÿ¨ÿ±ÿß. ### üî© ⁄©ŸÜÿ™ÿ±ŸÑ ÿ≥ÿ∑ÿ≠ Ÿæÿß€å€åŸÜ - ÿØÿ≥ÿ™ÿ±ÿ≥€å Ÿà ⁄©ŸÜÿ™ÿ±ŸÑ ⁄©ÿßŸÖŸÑ ÿ®ÿ± ÿ≠ÿßŸÅÿ∏Ÿá ÿ≥€åÿ≥ÿ™ŸÖ Ÿà Ÿæÿ¥ÿ™Ÿá (stack).\n- Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å ÿßÿÆÿ™€åÿßÿ±€å ÿßÿ≤ ÿßÿ≥ŸÖÿ®ŸÑ€å ÿÆÿ∑€å (inline assembly).\n- ÿ®Ÿá‚ÄåÿµŸàÿ±ÿ™ Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂ ÿß€åŸÖŸÜ ÿßÿ≥ÿ™ÿå ÿßŸÖÿß ÿØÿ± ÿµŸàÿ±ÿ™ ŸÜ€åÿßÿ≤ ŸÖ€å‚Äåÿ™ŸàÿßŸÜ ÿ®ÿß ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ ÿ®ŸÑŸà⁄©‚ÄåŸáÿß€å ` ÿ®Ÿá ÿ™ŸÖÿßŸÖ ÿßŸÖ⁄©ÿßŸÜÿßÿ™ ÿØÿ≥ÿ™ÿ±ÿ≥€å ÿØÿßÿ¥ÿ™. ### üì¶ ÿ≥€åÿ≥ÿ™ŸÖ ŸÖÿß⁄òŸàŸÑ ÿ≤€åÿ®ÿß Ÿà ÿ¥ŸÅÿßŸÅ - ÿ≥€åÿ≥ÿ™ŸÖ ŸÖÿß⁄òŸàŸÑ ÿ™ŸÖ€åÿ≤ÿå ⁄ØŸà€åÿßÿå Ÿà ÿÆŸàÿßŸÜÿß.\n- ÿ®ÿØŸàŸÜ ŸÜ€åÿßÿ≤ ÿ®Ÿá ÿßÿ®ÿ≤ÿßÿ±Ÿáÿß€å Ÿæ€å⁄Ü€åÿØŸá ÿ≥ÿßÿÆÿ™ Ÿà ÿ≥ÿßÿ≤ (build tools)ÿå ŸÅŸÇÿ∑ ÿß€åŸÖŸæŸàÿ±ÿ™‚ÄåŸáÿß€å ÿ≥ÿßÿØŸá Ÿà ⁄©ŸÜÿ™ÿ±ŸÑ Ÿàÿßÿ®ÿ≥ÿ™⁄Ø€å Ÿàÿßÿ∂ÿ≠. ### üõ† ŸÖÿ®ÿ™ŸÜ€å ÿ®ÿ± llvm - ÿ®⁄©‚ÄåÿßŸÜÿØ ŸÇÿØÿ±ÿ™ŸÖŸÜÿØ ŸÖÿ®ÿ™ŸÜ€å ÿ®ÿ± llvm.\n- ÿ™ÿ®ÿØ€åŸÑ ŸÖÿ≥ÿ™ŸÇ€åŸÖ ÿ®Ÿá ⁄©ÿØ ÿ®ÿß€åŸÜÿ±€å ÿ≥ÿ±€åÿπ Ÿà ⁄©ÿßÿ±ÿ¢ŸÖÿØ.\n- Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å ÿßÿ≤ ⁄©ÿßŸÖŸæÿß€åŸÑ ŸÖÿ™ŸÇÿßÿ®ŸÑ (cross-compilation) Ÿà €å⁄©Ÿæÿßÿ±⁄ÜŸá‚Äåÿ≥ÿßÿ≤€å ÿ®ÿß ÿßÿ®ÿ≤ÿßÿ±Ÿáÿß€å ÿ¢€åŸÜÿØŸá. ### üîÑ Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å ÿßÿ≤ ŸáŸÖ‚Äåÿ≤ŸÖÿßŸÜ€å (ÿØÿ± ÿ≠ÿßŸÑ ÿ®ÿ±ÿ±ÿ≥€å Ÿà ÿ∑ÿ±ÿßÿ≠€å) - Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å ÿØÿ± ÿ≥ÿ∑ÿ≠ ÿ≤ÿ®ÿßŸÜ ÿ®ÿ±ÿß€å ŸáŸÖ‚Äåÿ≤ŸÖÿßŸÜ€åÿå ÿ®ÿØŸàŸÜ ŸÜ€åÿßÿ≤ ÿ®Ÿá ÿ±ÿßŸÜÿ™ÿß€åŸÖ.\n- ŸÖÿ®ÿ™ŸÜ€å ÿ®ÿ± ÿßŸÑ⁄ØŸàŸáÿß€å ŸÖÿßŸÑ⁄©€åÿ™ Ÿà ŸÖÿØ€åÿ±€åÿ™ ŸÖŸÜÿßÿ®ÿπ ⁄©Ÿá ÿØÿ± ÿ≤ŸÖ€åŸÜŸá‚Äå€å ŸáŸÖ‚Äåÿ≤ŸÖÿßŸÜ€å ŸÜ€åÿ≤ ⁄©ÿßÿ±ÿ®ÿ±ÿØ ÿØÿßÿ±ŸÜÿØ. --- ## üë§ ÿß€åŸÜ ÿ≤ÿ®ÿßŸÜ ÿ®ÿ±ÿß€å ⁄ÜŸá ⁄©ÿ≥ÿßŸÜ€å ÿ∑ÿ±ÿßÿ≠€å ÿ¥ÿØŸá ÿßÿ≥ÿ™ÿü ÿ≥ÿß€åÿ±Ÿàÿ≥ ŸÖŸÜÿßÿ≥ÿ® ÿßÿ≥ÿ™ ÿ®ÿ±ÿß€å: - ÿ™Ÿàÿ≥ÿπŸá‚ÄåÿØŸáŸÜÿØ⁄ØÿßŸÜ ÿ≥€åÿ≥ÿ™ŸÖ ⁄©Ÿá ÿπÿßÿ¥ŸÇ **c** Ÿáÿ≥ÿ™ŸÜÿØ ŸàŸÑ€å ÿ®Ÿá‚ÄåÿØŸÜÿ®ÿßŸÑ ŸÜÿ≥ÿÆŸá‚Äåÿß€å ŸÖÿØÿ±ŸÜ Ÿà ÿ®ÿØŸàŸÜ gc Ÿáÿ≥ÿ™ŸÜÿØ.\n- ÿ®ÿ±ŸÜÿßŸÖŸá‚ÄåŸÜŸà€åÿ≥ÿßŸÜ€å ⁄©Ÿá ÿßÿ≤ **ŸÖŸÜÿ≠ŸÜ€å €åÿßÿØ⁄Ø€åÿ±€å rust** ÿÆÿ≥ÿ™Ÿá ÿ¥ÿØŸá‚ÄåÿßŸÜÿØ ŸàŸÑ€å ŸáŸÖ⁄ÜŸÜÿßŸÜ ÿ®Ÿá ÿØŸÜÿ®ÿßŸÑ ÿßŸÖŸÜ€åÿ™ ÿ≠ÿßŸÅÿ∏Ÿá Ÿà ÿπŸÖŸÑ⁄©ÿ±ÿØ ÿ®ÿßŸÑÿß Ÿáÿ≥ÿ™ŸÜÿØ.\n- ÿ™Ÿàÿ≥ÿπŸá‚ÄåÿØŸáŸÜÿØ⁄ØÿßŸÜ ÿ≥ÿ∑ÿ≠ Ÿæÿß€å€åŸÜ €åÿß ÿßŸÖÿ®ÿØÿØ (embedded/os) ⁄©Ÿá ŸÜ€åÿßÿ≤ ÿ®Ÿá **ÿ±ÿßŸÜÿ™ÿß€åŸÖ ÿ≥ÿ®⁄© Ÿà ⁄©ŸÜÿ™ÿ±ŸÑ ⁄©ÿßŸÖŸÑ ÿ®ÿ± ÿ≥ÿÆÿ™‚ÄåÿßŸÅÿ≤ÿßÿ±** ÿØÿßÿ±ŸÜÿØ.\n- Ÿáÿ± ⁄©ÿ≥€å ⁄©Ÿá ÿ®Ÿá‚ÄåÿØŸÜÿ®ÿßŸÑ ÿ≤ÿ®ÿßŸÜ€å ÿ≥ÿ∑ÿ≠ Ÿæÿß€å€åŸÜÿå ÿ≤€åÿ®ÿß Ÿà ÿÆŸàÿßŸÜÿß ÿßÿ≥ÿ™ ⁄©Ÿá ÿ®Ÿá ÿ¥ÿπŸàÿ± ÿßŸà ÿßÿ≠ÿ™ÿ±ÿßŸÖ ŸÖ€å‚Äå⁄Øÿ∞ÿßÿ±ÿØ. ŸÅÿπŸÑÿßŸã Ÿæ€åÿ¥ŸÜŸáÿßÿØ ŸÜŸÖ€å‚Äåÿ¥ŸàÿØ ÿ®ÿ±ÿß€å: - ÿßŸÅÿ±ÿßÿØ ⁄©ÿßŸÖŸÑÿßŸã ŸÖÿ®ÿ™ÿØ€å ⁄©Ÿá ÿ™ÿ¨ÿ±ÿ®Ÿá‚Äåÿß€å ÿØÿ± ÿ≤ÿ®ÿßŸÜ‚ÄåŸáÿß€å ÿ≥ÿ∑ÿ≠ Ÿæÿß€å€åŸÜ ŸÜÿØÿßÿ±ŸÜÿØ.\n- ÿ™Ÿàÿ≥ÿπŸá‚ÄåÿØŸáŸÜÿØ⁄ØÿßŸÜ€å ⁄©Ÿá ÿ®Ÿá ÿØŸÜÿ®ÿßŸÑ ŸÖÿØ€åÿ±€åÿ™ ÿ≠ÿßŸÅÿ∏Ÿá ÿÆŸàÿØ⁄©ÿßÿ± Ÿà ÿß€åŸÖŸÜ€å ÿ±ÿßŸÜÿ™ÿß€åŸÖ ÿ®ÿØŸàŸÜ ÿ¢ÿ¥ŸÜÿß€å€å ÿ®ÿß ÿßŸÑ⁄ØŸàŸáÿß€å ÿ™ÿÆÿµ€åÿµ ÿ≠ÿßŸÅÿ∏Ÿá Ÿáÿ≥ÿ™ŸÜÿØ. --- ## üß™ Ÿàÿ∂ÿπ€åÿ™ ŸÅÿπŸÑ€å ÿ≤ÿ®ÿßŸÜ ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿØÿ± ÿ≠ÿßŸÑ ÿ™Ÿàÿ≥ÿπŸá ŸÅÿπÿßŸÑ ÿßÿ≥ÿ™ Ÿà ÿ®ÿß ÿ≥ÿ±ÿπÿ™ ÿØÿ± ÿ≠ÿßŸÑ ÿ±ÿ¥ÿØ ÿßÿ≥ÿ™. ÿ®ÿ±ÿß€å ŸÖÿ¥ÿßŸáÿØŸá ŸÜŸÇÿ¥Ÿá ÿ±ÿßŸá ⁄©ÿßŸÖŸÑ ÿ™Ÿàÿ≥ÿπŸáÿå ŸÑÿ∑ŸÅÿßŸã ÿ®Ÿá [Ÿæÿ±Ÿà⁄òŸá ÿ±ÿ≥ŸÖ€å ŸÖÿß ÿØÿ± ⁄Ø€åÿ™‚ÄåŸáÿßÿ®](https://github.com/orgs/cyrus-lang/projects/1) ŸÖÿ±ÿßÿ¨ÿπŸá ⁄©ŸÜ€åÿØ. --- ## üìö ÿ®ÿßŸàÿ±Ÿáÿß€å ÿ∑ÿ±ÿßÿ≠€å - **ÿ≥ÿßÿØ⁄Ø€åÿå €å⁄© ŸÇÿßÿ®ŸÑ€åÿ™ ÿßÿ≥ÿ™.**\n- **ÿÆŸàÿßŸÜÿß€å€åÿå ÿ®ÿÆÿ¥€å ÿßÿ≤ ÿπŸÖŸÑ⁄©ÿ±ÿØ ÿßÿ≥ÿ™.**\n- **ÿπŸÖŸÑ⁄©ÿ±ÿØÿå ÿ∫€åÿ±ŸÇÿßÿ®ŸÑ ŸÖÿ∞ÿß⁄©ÿ±Ÿá ÿßÿ≥ÿ™.**\n- **⁄©ŸÜÿ™ÿ±ŸÑ ÿ®ÿß€åÿØ ÿØÿ± ÿØÿ≥ÿ™ÿßŸÜ ÿ®ÿ±ŸÜÿßŸÖŸá‚ÄåŸÜŸà€åÿ≥ ÿ®ÿßÿ¥ÿØ.**",
    "language": "fa",
    "category": "getting-started"
  },
  {
    "id": "fa-getting-started-getting-started",
    "title": "ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜ€åÿØ",
    "path": "/fa/docs/getting-started/getting-started",
    "content": "ÿ®Ÿá ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€åÿØ! ÿß€åŸÜ ÿ±ÿßŸáŸÜŸÖÿß ÿ®Ÿá ÿ¥ŸÖÿß ⁄©ŸÖ⁄© ŸÖ€å‚Äå⁄©ŸÜÿØ ÿ™ÿß ÿßŸàŸÑ€åŸÜ ŸÇÿØŸÖ‚ÄåŸáÿß€å ÿÆŸàÿØ ÿ±ÿß ÿØÿ± ÿØŸÜ€åÿß€å ÿ®ÿ±ŸÜÿßŸÖŸá‚ÄåŸÜŸà€åÿ≥€å ÿ®ÿß ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿ®ÿ±ÿØÿßÿ±€åÿØ.",
    "searchable": "ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜ€åÿØ # ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜ€åÿØ ÿ®Ÿá ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€åÿØ! ÿß€åŸÜ ÿ±ÿßŸáŸÜŸÖÿß ÿ®Ÿá ÿ¥ŸÖÿß ⁄©ŸÖ⁄© ŸÖ€å‚Äå⁄©ŸÜÿØ ÿ™ÿß ÿßŸàŸÑ€åŸÜ ŸÇÿØŸÖ‚ÄåŸáÿß€å ÿÆŸàÿØ ÿ±ÿß ÿØÿ± ÿØŸÜ€åÿß€å ÿ®ÿ±ŸÜÿßŸÖŸá‚ÄåŸÜŸà€åÿ≥€å ÿ®ÿß ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿ®ÿ±ÿØÿßÿ±€åÿØ.",
    "language": "fa",
    "category": "getting-started"
  },
  {
    "id": "fa-getting-started-hello-world",
    "title": "ÿ≥ŸÑÿßŸÖ ÿØŸÜ€åÿß",
    "path": "/fa/docs/getting-started/hello-world",
    "content": "ÿßŸàŸÑ€åŸÜ ÿ®ÿ±ŸÜÿßŸÖŸá ÿ¥ŸÖÿß ÿØÿ± ÿ≥ÿß€åÿ±Ÿàÿ≥:",
    "searchable": "ÿ≥ŸÑÿßŸÖ ÿØŸÜ€åÿß # ÿ≥ŸÑÿßŸÖ ÿØŸÜ€åÿß ÿßŸàŸÑ€åŸÜ ÿ®ÿ±ŸÜÿßŸÖŸá ÿ¥ŸÖÿß ÿØÿ± ÿ≥ÿß€åÿ±Ÿàÿ≥: ``\nfn main() {\n    println(\"ÿ≥ŸÑÿßŸÖ ÿØŸÜ€åÿß!\");\n}\n``` ÿß€åŸÜ ÿ≥ÿßÿØŸá‚Äåÿ™ÿ±€åŸÜ ÿ®ÿ±ŸÜÿßŸÖŸá ŸÖŸÖ⁄©ŸÜ ÿØÿ± ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿßÿ≥ÿ™ ⁄©Ÿá ÿπÿ®ÿßÿ±ÿ™ \"ÿ≥ŸÑÿßŸÖ ÿØŸÜ€åÿß\" ÿ±ÿß ⁄ÜÿßŸæ ŸÖ€å‚Äå⁄©ŸÜÿØ.",
    "language": "fa",
    "category": "getting-started"
  },
  {
    "id": "fa-getting-started-install-compiler-binary",
    "title": "ŸÜÿµÿ® ⁄©ÿßŸÖŸæÿß€åŸÑÿ±",
    "path": "/fa/docs/getting-started/install-compiler-binary",
    "content": "ÿ®ÿ±ÿß€å ÿ¥ÿ±Ÿàÿπ ⁄©ÿßÿ± ÿ®ÿß ÿ≥ÿß€åÿ±Ÿàÿ≥ÿå ÿßÿ®ÿ™ÿØÿß ÿ®ÿß€åÿØ ⁄©ÿßŸÖŸæÿß€åŸÑÿ± ÿ±ÿß ŸÜÿµÿ® ⁄©ŸÜ€åÿØ.",
    "searchable": "ŸÜÿµÿ® ⁄©ÿßŸÖŸæÿß€åŸÑÿ± # ŸÜÿµÿ® ⁄©ÿßŸÖŸæÿß€åŸÑÿ± ÿ®ÿ±ÿß€å ÿ¥ÿ±Ÿàÿπ ⁄©ÿßÿ± ÿ®ÿß ÿ≥ÿß€åÿ±Ÿàÿ≥ÿå ÿßÿ®ÿ™ÿØÿß ÿ®ÿß€åÿØ ⁄©ÿßŸÖŸæÿß€åŸÑÿ± ÿ±ÿß ŸÜÿµÿ® ⁄©ŸÜ€åÿØ. ## Ÿà€åŸÜÿØŸàÿ≤ ``\nwinget install cyrus-lang.compiler\n``` ## ŸÑ€åŸÜŸà⁄©ÿ≥ ```bash\ncurl -fssl https://get.cyrus-lang.org | sh\n``` ## ŸÖ⁄© ```bash\nbrew install cyrus-lang\n```",
    "language": "fa",
    "category": "getting-started"
  },
  {
    "id": "fa-getting-started-introduction",
    "title": "ŸÖÿπÿ±ŸÅ€å",
    "path": "/fa/docs/getting-started/introduction",
    "content": "ÿ®Ÿá ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ ÿ±ÿ≥ŸÖ€å ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€åÿØ. ÿØÿ± ÿß€åŸÜÿ¨ÿß ŸáŸÖŸá ⁄Ü€åÿ≤Ÿáÿß€å€å ⁄©Ÿá ÿ®ÿ±ÿß€å ÿ¥ÿ±Ÿàÿπ ÿ®ÿß ÿ≤ÿ®ÿßŸÜ ÿ®ÿ±ŸÜÿßŸÖŸá‚ÄåŸÜŸà€åÿ≥€å ŸÖÿØÿ±ŸÜÿå ÿ®€åÿßŸÜ⁄Øÿ± Ÿà ⁄©ÿßÿ±ÿ¢ŸÖÿØ ŸÖÿß ŸÜ€åÿßÿ≤ ÿØÿßÿ±€åÿØ ÿ±ÿß Ÿæ€åÿØÿß ÿÆŸàÿßŸá€åÿØ ⁄©ÿ±ÿØ.",
    "searchable": "ŸÖÿπÿ±ŸÅ€å <erroralert title=\"ÿØÿ± ÿ≠ÿßŸÑ ÿ™Ÿàÿ≥ÿπŸá\" /> # ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ ÿ®Ÿá ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ ÿ±ÿ≥ŸÖ€å ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€åÿØ. ÿØÿ± ÿß€åŸÜÿ¨ÿß ŸáŸÖŸá ⁄Ü€åÿ≤Ÿáÿß€å€å ⁄©Ÿá ÿ®ÿ±ÿß€å ÿ¥ÿ±Ÿàÿπ ÿ®ÿß ÿ≤ÿ®ÿßŸÜ ÿ®ÿ±ŸÜÿßŸÖŸá‚ÄåŸÜŸà€åÿ≥€å ŸÖÿØÿ±ŸÜÿå ÿ®€åÿßŸÜ⁄Øÿ± Ÿà ⁄©ÿßÿ±ÿ¢ŸÖÿØ ŸÖÿß ŸÜ€åÿßÿ≤ ÿØÿßÿ±€åÿØ ÿ±ÿß Ÿæ€åÿØÿß ÿÆŸàÿßŸá€åÿØ ⁄©ÿ±ÿØ. <br /> <div classname=\"flex flex-col md:flex-row gap-4\">\n  <card classname=\"shadow-lg h-full\">\n    <cardheader>\n      <cardtitle classname=\"flex items-center gap-2 text-xl md:text-2xl\">\n        ÿ®ÿ±ÿß€å ÿ™ÿßÿ≤Ÿá‚ÄåŸàÿßÿ±ÿØÿßŸÜ\n      </cardtitle>\n    </cardheader>\n    <cardcontent>\n      <div classname=\"space-y-4\">\n        <div classname=\"text-base md:text-lg text-gray-600 dark:text-muted-foreground\">\n          ÿß⁄Øÿ± ÿ™ÿßÿ≤Ÿá ÿ®ÿß ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿ¢ÿ¥ŸÜÿß ÿ¥ÿØŸá‚Äåÿß€åÿØÿå ÿ®ÿß ÿ¢ŸÖŸàÿ≤ÿ¥ ÿ¨ÿßŸÖÿπ ŸÖÿß ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜ€åÿØ ÿ™ÿß ÿßÿµŸàŸÑ\n          ÿßŸàŸÑ€åŸá ÿ±ÿß €åÿßÿØ ÿ®⁄Ø€åÿ±€åÿØ Ÿà ÿ≥ÿ±€åÿπÿßŸã Ÿæ€åÿ¥ÿ±ŸÅÿ™ ⁄©ŸÜ€åÿØ.\n        </div>\n        <link href=\"/docs/tutorial/basic-syntax\" classname=\"mt-2 block\">\n          <button classname=\"w-full md:w-auto\">ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜ€åÿØ</button>\n        </link>\n      </div>\n    </cardcontent>\n  </card>   <card classname=\"shadow-lg h-full\">\n    <cardheader>\n      <cardtitle classname=\"flex items-center gap-2 text-xl md:text-2xl\">\n        ŸÖÿ±ÿ¨ÿπ ÿ≤ÿ®ÿßŸÜ\n      </cardtitle>\n    </cardheader>\n    <cardcontent>\n      <div classname=\"space-y-4\">\n        <div classname=\"text-base md:text-lg text-gray-600 dark:text-muted-foreground\">\n          ÿ®ÿ±ÿß€å ÿ®ÿ±ÿ±ÿ≥€å ÿØŸÇ€åŸÇ ÿßŸÜŸàÿßÿπ ÿØÿßÿÆŸÑ€åÿå ÿ™Ÿàÿßÿ®ÿπ Ÿà ŸÖÿß⁄òŸàŸÑ‚ÄåŸáÿß€å ÿ≥ÿß€åÿ±Ÿàÿ≥ÿå ŸÖÿ±ÿ¨ÿπ ÿ≤ÿ®ÿßŸÜ ŸÖÿß ÿ±ÿß\n          ÿ®ÿ±ÿ±ÿ≥€å ⁄©ŸÜ€åÿØ.\n        </div>\n        <link href=\"/docs/langref\" classname=\"mt-2 block\">\n          <button variant=\"outline\" classname=\"w-full md:w-auto\">\n            ŸÖÿ¥ÿßŸáÿØŸá ŸÖÿ±ÿ¨ÿπ\n          </button>\n        </link>\n      </div>\n    </cardcontent>\n  </card>\n</div>{\" \"}",
    "language": "fa",
    "category": "getting-started"
  },
  {
    "id": "fa-getting-started-roadmap",
    "title": "ŸÜŸÇÿ¥Ÿá ÿ±ÿßŸá",
    "path": "/fa/docs/getting-started/roadmap",
    "content": "- [x] ŸÜÿ≠Ÿà Ÿæÿß€åŸá",
    "searchable": "ŸÜŸÇÿ¥Ÿá ÿ±ÿßŸá # ŸÜŸÇÿ¥Ÿá ÿ±ÿßŸá ## ŸÜÿ≥ÿÆŸá 1.0 (q2 2024) - [x] ŸÜÿ≠Ÿà Ÿæÿß€åŸá\n- [x] ÿ≥€åÿ≥ÿ™ŸÖ ŸÜŸàÿπ\n- [x] ⁄©ÿßŸÖŸæÿß€åŸÑÿ± Ÿæÿß€åŸá\n- [ ] ⁄©ÿ™ÿßÿ®ÿÆÿßŸÜŸá ÿßÿ≥ÿ™ÿßŸÜÿØÿßÿ±ÿØ\n- [ ] ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ ⁄©ÿßŸÖŸÑ ## ŸÜÿ≥ÿÆŸá 1.1 (q3 2024) - [ ] ŸÖÿß⁄©ÿ±ŸàŸáÿß\n- [ ] ŸÖÿØ€åÿ±€åÿ™ ÿ≠ÿßŸÅÿ∏Ÿá Ÿæ€åÿ¥ÿ±ŸÅÿ™Ÿá\n- [ ] ÿ®Ÿá€åŸÜŸá‚Äåÿ≥ÿßÿ≤€å‚ÄåŸáÿß€å ÿ®€åÿ¥ÿ™ÿ± ## ŸÜÿ≥ÿÆŸá 2.0 (q4 2024) - [ ] ŸáŸÖÿ≤ŸÖÿßŸÜ€å\n- [ ] ffi\n- [ ] Ÿæ⁄©€åÿ¨ ŸÖŸÜ€åÿ¨ÿ±",
    "language": "fa",
    "category": "getting-started"
  },
  {
    "id": "fa-tutorial-basic-syntax",
    "title": "ŸÜÿ≠Ÿà Ÿæÿß€åŸá",
    "path": "/fa/docs/tutorial/basic-syntax",
    "content": "ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿØÿßÿ±ÿß€å ŸÜÿ≠Ÿà ÿ≥ÿßÿØŸá Ÿà ŸÇÿßÿ®ŸÑ ŸÅŸáŸÖ€å ÿßÿ≥ÿ™ ⁄©Ÿá €åÿßÿØ⁄Ø€åÿ±€å ÿ¢ŸÜ ÿ¢ÿ≥ÿßŸÜ ÿßÿ≥ÿ™.",
    "searchable": "ŸÜÿ≠Ÿà Ÿæÿß€åŸá # ŸÜÿ≠Ÿà Ÿæÿß€åŸá ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿØÿßÿ±ÿß€å ŸÜÿ≠Ÿà ÿ≥ÿßÿØŸá Ÿà ŸÇÿßÿ®ŸÑ ŸÅŸáŸÖ€å ÿßÿ≥ÿ™ ⁄©Ÿá €åÿßÿØ⁄Ø€åÿ±€å ÿ¢ŸÜ ÿ¢ÿ≥ÿßŸÜ ÿßÿ≥ÿ™. ## ÿ™Ÿàÿ∂€åÿ≠ÿßÿ™ ``\n// ÿß€åŸÜ €å⁄© ÿ™Ÿàÿ∂€åÿ≠ ÿ™⁄© ÿÆÿ∑€å ÿßÿ≥ÿ™\n/* ÿß€åŸÜ €å⁄© ÿ™Ÿàÿ∂€åÿ≠ ⁄ÜŸÜÿØ ÿÆÿ∑€å ÿßÿ≥ÿ™ */\n``` ## ÿ´ÿßÿ®ÿ™‚ÄåŸáÿß ```cyrus\n// ÿ±ÿ¥ÿ™Ÿá‚ÄåŸáÿß\nlet message = \"ÿ≥ŸÑÿßŸÖ ÿØŸÜ€åÿß\"; // ÿßÿπÿØÿßÿØ\nlet number = 42;\nlet float = 3.14; // ÿ®ŸàŸÑ€åŸÜ\nlet is_true = true;\nlet is_false = false;\n``` ## ⁄©ÿßÿ±ÿß⁄©ÿ™ÿ±Ÿáÿß€å ŸÅÿ±ÿßÿ± ```cyrus\nlet newline = \"\\n\";\nlet tab = \"\\t\";\nlet quote = \"\\\"\";\n``` ## ÿßŸÜŸàÿßÿπ Ÿæÿß€åŸá ```cyrus\nlet integer: i32 = 42;\nlet float: f64 = 3.14;\nlet boolean: bool = true;\nlet string: str = \"ÿ≥ŸÑÿßŸÖ\";\n``` ## ÿ´ÿßÿ®ÿ™‚ÄåŸáÿß€å ÿπÿØÿØ€å ```cyrus\nlet binary = 0b1010;      // ÿØŸàÿØŸà€å€å\nlet hex = 0xff;           // Ÿá⁄Øÿ≤ÿßÿØÿ≥€åŸÖÿßŸÑ\nlet octal = 0o77;         // Ÿáÿ¥ÿ™‚Äåÿ™ÿß€å€å\n``` ## ÿ¢ÿ±ÿß€åŸá‚ÄåŸáÿß ```cyrus\nlet numbers = [1, 2, 3, 4, 5];\nlet first = numbers[0];\n``` ## ÿ®ÿ±ÿØÿßÿ±Ÿáÿß ```cyrus\nlet mut vector = [1, 2, 3];\nvector.push(4);\n``` ## ÿßÿ¥ÿßÿ±Ÿá‚Äå⁄Øÿ±Ÿáÿß ```cyrus\nlet value = 42;\nlet pointer = &value;\n```",
    "language": "fa",
    "category": "tutorial"
  },
  {
    "id": "fa-tutorial-functions",
    "title": "ÿ™Ÿàÿßÿ®ÿπ",
    "path": "/fa/docs/tutorial/functions",
    "content": "ÿ™Ÿàÿßÿ®ÿπ ÿØÿ± ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿ®ÿ±ÿß€å ⁄Øÿ±ŸàŸá‚Äåÿ®ŸÜÿØ€å ⁄©ÿØ Ÿà ŸÇÿßÿ®ŸÑ€åÿ™ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÖÿ¨ÿØÿØ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàŸÜÿØ.",
    "searchable": "ÿ™Ÿàÿßÿ®ÿπ # ÿ™Ÿàÿßÿ®ÿπ ÿ™Ÿàÿßÿ®ÿπ ÿØÿ± ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿ®ÿ±ÿß€å ⁄Øÿ±ŸàŸá‚Äåÿ®ŸÜÿØ€å ⁄©ÿØ Ÿà ŸÇÿßÿ®ŸÑ€åÿ™ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÖÿ¨ÿØÿØ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàŸÜÿØ. ## ÿ™ÿπÿ±€åŸÅ ÿ™ÿßÿ®ÿπ ÿ≥ÿßÿØŸá ``\nfn greet() {\n    println(\"ÿ≥ŸÑÿßŸÖ!\");\n}\n``` ## ÿ™ÿßÿ®ÿπ ÿ®ÿß Ÿæÿßÿ±ÿßŸÖÿ™ÿ± ```cyrus\nfn greet(name: str) {\n    println(\"ÿ≥ŸÑÿßŸÖ \" + name + \"!\");\n}\n``` ## ÿ™ÿßÿ®ÿπ ÿ®ÿß ŸÖŸÇÿØÿßÿ± ÿ®ÿßÿ≤⁄Øÿ¥ÿ™€å ```cyrus\nfn add(a: i32, b: i32) -> i32 {\n    return a + b;\n}\n``` ## ÿ™ÿßÿ®ÿπ ÿ®ÿß ŸÖŸÇÿØÿßÿ± ÿ®ÿßÿ≤⁄Øÿ¥ÿ™€å ÿ∂ŸÖŸÜ€å ```cyrus\nfn multiply(a: i32, b: i32) -> i32 {\n    a * b  // ÿ¢ÿÆÿ±€åŸÜ ÿπÿ®ÿßÿ±ÿ™ ÿ®Ÿá ÿπŸÜŸàÿßŸÜ ŸÖŸÇÿØÿßÿ± ÿ®ÿßÿ≤⁄Øÿ¥ÿ™€å ÿØÿ± ŸÜÿ∏ÿ± ⁄Øÿ±ŸÅÿ™Ÿá ŸÖ€å‚Äåÿ¥ŸàÿØ\n}\n``` ## ŸÅÿ±ÿßÿÆŸàÿßŸÜ€å ÿ™Ÿàÿßÿ®ÿπ ```cyrus\nfn main() {\n    greet();\n    greet(\"ÿßÿ≠ŸÖÿØ\");     let result = add(5, 3);\n    println(\"ŸÜÿ™€åÿ¨Ÿá: \" + result);\n}\n```",
    "language": "fa",
    "category": "tutorial"
  },
  {
    "id": "fa-tutorial-installation",
    "title": "ŸÜÿµÿ®",
    "path": "/fa/docs/tutorial/installation",
    "content": "ŸÇÿ®ŸÑ ÿßÿ≤ ÿ¥ÿ±Ÿàÿπ ÿ¢ŸÖŸàÿ≤ÿ¥ÿå ÿ®ÿß€åÿØ ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿ±ÿß ŸÜÿµÿ® ⁄©ŸÜ€åÿØ.",
    "searchable": "ŸÜÿµÿ® # ŸÜÿµÿ® ÿ≥ÿß€åÿ±Ÿàÿ≥ ŸÇÿ®ŸÑ ÿßÿ≤ ÿ¥ÿ±Ÿàÿπ ÿ¢ŸÖŸàÿ≤ÿ¥ÿå ÿ®ÿß€åÿØ ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿ±ÿß ŸÜÿµÿ® ⁄©ŸÜ€åÿØ. ## ÿ±Ÿàÿ¥‚ÄåŸáÿß€å ŸÜÿµÿ® ### 1. ŸÜÿµÿ® ŸÖÿ≥ÿ™ŸÇ€åŸÖ ``\ncurl -fssl https://get.cyrus-lang.org | sh\n``` ### 2. ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ Ÿæ⁄©€åÿ¨ ŸÖŸÜ€åÿ¨ÿ± **Ÿà€åŸÜÿØŸàÿ≤:** ```powershell\nwinget install cyrus-lang.compiler\n``` **ŸÑ€åŸÜŸà⁄©ÿ≥:** ```bash\nsudo apt install cyrus-lang  # ubuntu/debian\nsudo dnf install cyrus-lang  # fedora\n``` **ŸÖ⁄©:** ```bash\nbrew install cyrus-lang\n``` ## ÿ™ÿ£€å€åÿØ ŸÜÿµÿ® ```bash\ncyrus version\n``` ÿ®ÿß€åÿØ ÿÆÿ±Ÿàÿ¨€å ŸÖÿ¥ÿßÿ®Ÿá ÿß€åŸÜ ÿ®ÿ®€åŸÜ€åÿØ: ```\ncyrus 1.0.0\n```",
    "language": "fa",
    "category": "tutorial"
  },
  {
    "id": "fa-tutorial-tutorial",
    "title": "ÿ¢ŸÖŸàÿ≤ÿ¥",
    "path": "/fa/docs/tutorial/tutorial",
    "content": "ÿß€åŸÜ ÿ®ÿÆÿ¥ ÿ¥ÿßŸÖŸÑ ÿ¢ŸÖŸàÿ≤ÿ¥‚ÄåŸáÿß€å ⁄©ÿßŸÖŸÑ ÿ®ÿ±ÿß€å €åÿßÿØ⁄Ø€åÿ±€å ÿ≤ÿ®ÿßŸÜ ÿ®ÿ±ŸÜÿßŸÖŸá‚ÄåŸÜŸà€åÿ≥€å ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿßÿ≥ÿ™.",
    "searchable": "ÿ¢ŸÖŸàÿ≤ÿ¥ # ÿ¢ŸÖŸàÿ≤ÿ¥ ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿß€åŸÜ ÿ®ÿÆÿ¥ ÿ¥ÿßŸÖŸÑ ÿ¢ŸÖŸàÿ≤ÿ¥‚ÄåŸáÿß€å ⁄©ÿßŸÖŸÑ ÿ®ÿ±ÿß€å €åÿßÿØ⁄Ø€åÿ±€å ÿ≤ÿ®ÿßŸÜ ÿ®ÿ±ŸÜÿßŸÖŸá‚ÄåŸÜŸà€åÿ≥€å ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿßÿ≥ÿ™.",
    "language": "fa",
    "category": "tutorial"
  },
  {
    "id": "fa-tutorial-variables",
    "title": "ŸÖÿ™ÿ∫€åÿ±Ÿáÿß",
    "path": "/fa/docs/tutorial/variables",
    "content": "ŸÖÿ™ÿ∫€åÿ±Ÿáÿß ÿØÿ± ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿ®ÿ±ÿß€å ÿ∞ÿÆ€åÿ±Ÿá ÿØÿßÿØŸá‚ÄåŸáÿß ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàŸÜÿØ.",
    "searchable": "ŸÖÿ™ÿ∫€åÿ±Ÿáÿß # ŸÖÿ™ÿ∫€åÿ±Ÿáÿß ŸÖÿ™ÿ∫€åÿ±Ÿáÿß ÿØÿ± ÿ≥ÿß€åÿ±Ÿàÿ≥ ÿ®ÿ±ÿß€å ÿ∞ÿÆ€åÿ±Ÿá ÿØÿßÿØŸá‚ÄåŸáÿß ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàŸÜÿØ. #### ÿ™ÿπÿ±€åŸÅ ŸÖÿ™ÿ∫€åÿ± ``\nlet name = \"ÿßÿ≠ŸÖÿØ\";\nlet age = 25;\nlet height = 1.75;\n``` ####  ŸÖÿ™ÿ∫€åÿ±Ÿáÿß€å ŸÇÿßÿ®ŸÑ ÿ™ÿ∫€å€åÿ± ```cyrus\nlet mut counter = 0;\ncounter = counter + 1;\n``` ####  ÿßŸÜŸàÿßÿπ ÿµÿ±€åÿ≠ ```cyrus\nlet name: str = \"ÿßÿ≠ŸÖÿØ\";\nlet age: i32 = 25;\nlet is_student: bool = true;\n``` ####  ÿ´ÿßÿ®ÿ™‚ÄåŸáÿß ```cyrus\nconst pi = 3.14159;\nconst max_size = 100;\n```",
    "language": "fa",
    "category": "tutorial"
  }
]