---
title: Structs
weight: 6
---

# Structs 

Structs in Cyrus are **user-defined composite types** that allow grouping related data together.  They are similar to `struct` in C/C++ but follow Cyrus' type system rules.

<br />

## Defining a Struct

Use the `struct` keyword, followed by the name and fields:

```cyrus
struct User {
    name: char*;
    age: uint;
    king: bool;
}
```

<br />

## Initializing a Struct

Structs can be initialized using **struct literals**:

```cyrus
#user = User {
    name: "Cyrus",
    age: 2500,
    king: true
};
```

<br />

## Accessing Struct Fields

You can access struct fields using the **dot (`.`) operator**:

```cyrus
user.name; // Output: Cyrus
user.age;  // Output: 2500
user.king; // Output: true
```

<br />

## Methods 

Structs can define functions inside their body, called **methods**.

```cyrus
pub struct Logger {
    pub group: char*;

    pub fn new(group: char*) Logger { 
        Logger.logger_initialized();
        return Logger { group: group };
    }

    inline fn logger_initialized() {
        libc::fprintf(libc::stdout, "Logger init.\n");
    }

    pub fn logf(&self, format: char*) {
        libc::printf("[info][%s] %s\n", self->group, format);
    }

    pub inline fn errorf(self, format: char*) {
        libc::fprintf(libc::stderr, "[error][%s] %s\n", self->group, format);
    }
}
```

<br />

## Static Methods

Static methods do not require a struct instance. Called on the struct type itself. It often used as constructor or helper functions.

```cyrus
pub fn new(group: char*) Logger {
    return Logger { group: group };
}
```

<br />

## Instance Methods

Instance methods operate on a struct instance and can access its fields.

```cyrus
pub fn logf(&self, format: char*) {
    libc::printf("[info][%s] %s\n", self->group, format);
}

pub fn errorf(self, format: char*) {
    libc::fprintf(libc::stderr, "[error][%s] %s\n", self->group, format);
}
```

<br />

## Reference vs Copy

Cyrus allows controlling how instance methods receive the struct:

- `&self` → passes a **reference** to the instance (does not copy)  
- `self` → passes a **copy** of the instance (moves it)

```cyrus
pub fn logf(&self, format: char*) { ... } // reference
pub fn errorf(self, format: char*) { ... } // copy
```

Note: Attempting to get a reference (&self) from a const-lvalue is not allowed. The compiler will issue an error to prevent modifying or referencing immutable data.

<br />

## Fat Arrows

In Cyrus, you can have pointers to structs. When accessing fields or calling methods through a pointer, you can use **fat pointers** (fat arrows) which **automatically dereference** the pointer.

```cyrus
#user = User { name: "Cyrus", age: 2500 }; 
#ptr = &user;

ptr->name; // Output: Cyrus
ptr->age; // Output: 2500
```

Note: Using **ptr->name** or **ptr->age** is equivalent to **{"(*ptr).name"}** and **{"(*ptr).age"}**.

<br />

## Local Structs

In Cyrus, structs can also be declared **locally inside functions**. This is useful when the type is only relevant to that function and should not pollute the global scope.

```cyrus
fn main() {
    struct User {
        name: char*;
        age: uint;
    }

    #user = User { name: "Cyrus", age: 2500 }; 
    libc::printf("%s is %d years old.\n", user.name, user.age);
}
```

<br />

## Unnamed Structs

Unnamed structs are struct values declared inline without defining a named type. They are useful for quick, one-off configurations or temporary data holders.

```cyrus
fn main() {
    #state = struct {
        name = "Cyrus",
        counter = 0,
    };

    config.name; 
    state.counter += 1;
}
```

Field types are inferred automatically.

<br />

## Typed Unnamed Struct

You can also specify field types explicitly:

```cyrus
#state = struct {
    name: char* = "Cyrus",
    counter: int = 0,
};
```

Note: Unnamed structs cannot define methods.

<br />

## Global Unnamed Structs

Unnamed structs are not limited to local scope. They can also be declared globally and accessed across functions (if marked public).

```cyrus
pub config = const struct {
    host = "127.0.0.1",
    port = 8080
};

fn main() {
    printf("host: %s\n", config.host);
    printf("port: %d\n", config.port);
}
```