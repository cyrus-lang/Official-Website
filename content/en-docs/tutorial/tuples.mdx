---
title: Tuples
weight: 9
---

# Tuples

A **tuple** is an ordered, fixed-size collection of values of possibly different types.  
They are lightweight and useful for grouping, returning, or destructuring multiple values without defining a struct.

<br />

## Tuple Literals

Tuples are written using parentheses, with elements separated by commas:

```cyrus
var t = (10, 20);
```

You can access tuple elements using numeric indices starting from `0`:

```cyrus
printf("%d\n", t.0); // prints 10
printf("%d\n", t.1); // prints 20
```

<br />

## Returning Tuples from Functions

Functions can return multiple values by specifying a tuple type as the return type:

```cyrus
fn pair(x: int, y: int) (int, int) {
    return (x, y);
}

pub fn main() {
    var (a, b) = pair(10, 20);
    printf("%d %d\n", a, b);
}
```

<br />

## Tuple Destructuring

Tuples can be **destructured** into individual variables in a single declaration.
Each element in the tuple pattern receives the corresponding element from the right-hand side.

```cyrus
pub fn main() {
    var (x, y) = (10, 20);
    printf("%d %d\n", x, y); // prints 10 20
}
```

<br />

## Nested Tuples

Tuples can contain other tuples.
Destructuring works recursively and matches the shape of the right-hand side:

```cyrus
pub fn main() {
    var (x, (y, z)) = (1, (2, 3));
    printf("%d %d %d\n", x, y, z); // prints 1, 2, 3
}
```

This form can be arbitrarily nested and follows the same destructuring logic for all levels.

<br />

## Explicit Tuple Types

You can explicitly annotate tuple types to make destructuring clearer or enforce type constraints:

```cyrus
var (a, (b, c)): (int, (int, char*)) = (10, (20, "Cyrus"));

printf("%d\n", a); // 10
printf("%d\n", b); // 20
printf("%s\n", c); // Cyrus
```

Type annotations ensure the tuple on the right-hand side matches the declared structure.

<br />

## Mutability

The `var` keyword makes all destructured elements mutable,
while `const` makes all of them immutable:

```cyrus
const (x, y) = (5, 6); // both immutable
var (p, q) = (7, 8);   // both mutable
```

<br />

## Restrictions

- Tuple destructuring is only allowed inside **functions** or **local scopes**.
- Destructuring without a right-hand side (e.g., `var (a, b);`) is **not allowed**,
  because tuple exports without initialization are meaningless in Cyrus.

Example of invalid code:

```cyrus
var (a, (b, c)); // tuple export without rhs is not allowed
```

Tuples in Cyrus are designed to be type-safe, efficient, and compiler-optimized.
Especially when destructuring nested or function-returned tuples.
