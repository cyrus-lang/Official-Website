---
title: Modules
weight: 10
---

# Modules

Cyrus features a **powerful module system** with **incremental compilation** and a **strong module cache**. Modules allow code organization, reusability, and proper scoping.

<br />

## Module Files

In Cyrus, **files are considered modules**.

Module files must:

- Use **snake_case** names
- Have the `.cyr` extension

Example: `user_utils.cyr` defines a module named `user_utils`.

Inside user_utils.cyr:

```cyrus
pub fn greet(name: str) {
  printf("Hello, %s!\n", name);
}
```

<br />

## Importing Modules

To use a module in another file, you import it.

```cyrus
import user_utils;

fn main() {
  user_utils::greet("Cyrus");
}
```

Notes:

- The entry file (the one you compile as main) cannot import other modules; it is considered the root.
- Only publicly exported symbols (declared with pub) are visible outside their module.

<br />

## Importing Single Symbols

You can import only a single symbol instead of the whole module:

```cyrus
import user_utils{greet};

fn main() {
  greet("Alice"); // no need for module path prefix
}
```

⚠️ You cannot import the same module both as a whole and with selected symbols in the same file. Choose one style.

<br />

## Importing Multiple Modules

For convenience, Cyrus supports grouped imports:

```cyrus
import (
  math_ops,
  user_utils{greet}
);

fn main() {
  #sum = math_ops::add(3, 5);
  greet("Bob");
}
```

<br />

## Renaming Imported Symbols

Renaming avoids conflicts or makes names clearer.   

- Renaming a symbol

```cyrus
import user_utils{greet: say_hello};

fn main() {
  say_hello("Charlie");
}
```

- Renaming a module

```cyrus
import my_math: math_ops;

fn main() {
  #result = my_math::mul(4, 6);
}
```