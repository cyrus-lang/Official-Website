---
title: Modules
weight: 11
---

# Modules

Cyrus features a **powerful module system** with **incremental compilation** and a **strong module cache**. Modules allow code organization, reusability, and proper scoping.

<br />

## Module Files

In Cyrus, **files are considered modules**.

Module files must:

- Use **snake_case** names
- Have the `.cyrus` extension

Example: `user_utils.cyrus` defines a module named `user_utils`.

Inside `user_utils.cyrus`:

```cyrus
pub fn greet(name: str) {
  printf("Hello, %s!\n", name);
}
```

<br />

## Importing Modules

To use a module in another file, you import it.

```cyrus
import user_utils;

pub fn main() {
  user_utils::greet("Cyrus");
}
```

Notes:

- The entry file (the one you compile as main) cannot import other modules; it is considered the root.
- Only publicly exported symbols (declared with pub) are visible outside their module.

<br />

## Importing Single Symbols

You can import only a single symbol instead of the whole module:

```cyrus
import user_utils{greet};

pub fn main() {
  greet("Alice"); // no need for module path prefix
}
```

<br />

## Importing Multiple Modules

For convenience, Cyrus supports grouped imports:

```cyrus
import (
  math_ops,
  user_utils{greet}
);

pub fn main() {
  var sum = math_ops::add(3, 5);
  greet("Bob");
}
```

<br />

## Renaming Imported Symbols

Renaming avoids conflicts or makes names clearer.   

- Renaming a symbol

```cyrus
import user_utils{greet as greet_renamed};

pub fn main() {
  greet_renamed("Charlie");
}
```

- Renaming a module

```cyrus
import math_ops as my_math;

pub fn main() {
  var result = my_math::mul(4, 6);
}
```